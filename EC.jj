
options {
    STATIC = false;
}

PARSER_BEGIN(EC)

import java.io.*;
import java.util.*;
import java.util.function.*;
import java.util.stream.Collectors;
import java.util.stream.*;
import java.lang.reflect.*;

public class EC {

    final Integer[] SENTENCES_BEGIN = new Integer[]
            {VARIABLE, ESTABLECER, INTERPRETAR, ESCRIBIR, INICIO_CONDICIONAL_SI, INICIO_CONDICIONAL_CONFORME,
            INICIO_CICLO_PARA, INICIO_CICLO_REPETIR, INICIO_CICLO_MIENTRAS};

    final ArrayList<String> tablaErrores = new ArrayList<String>();

    final StringBuilder codigoIntermedio = new StringBuilder();

    public class Ambito {

        public final HashMap<String, Expresion> tablaSimbolos;

        public Ambito(){
            tablaSimbolos = new HashMap<String, Expresion>();
        }

        public Ambito(Ambito from){
            this();

            tablaSimbolos.putAll(from.tablaSimbolos);
        }
    }

    public class Tupla<A, B> {
        private final A primero;
        private final B segundo;

        public Tupla(A primero, B segundo) {
            this.primero = primero;
            this.segundo = segundo;
        }

        public A getPrimero() {
            return primero;
        }

        public B getSegundo() {
            return segundo;
        }

        @Override
        public String toString() {
            return "(" + primero + ", " + segundo + ")";
        }
    }

    public class TipoDato {

        public final static TipoDato INDEFINIDO = new TipoDato(-2, "Indefinido");
        public final static TipoDato VACIO = new TipoDato(-1, "Vac√≠o");
        public final static TipoDato ENTERO = new TipoDato(ECConstants.ENTERO << 1, "Entero");
        public final static TipoDato FLOTANTE = new TipoDato(ECConstants.FLOTANTE << 1, "Flotante");
        public final static TipoDato CADENA = new TipoDato(ECConstants.CADENA << 1, "Cadena");
        public final static TipoDato CARACTER = new TipoDato(ECConstants.CARACTER << 1, "Caracter");
        public final static TipoDato BOOLEANO = new TipoDato(ECConstants.BOOLEANO << 1, "Booleano");

        public static desdeTipo(int tipoDato) {

            switch (tipoDato) {
                case -1:
                    return VACIO;
                case ECConstants.ENTERO << 1:
                    return ENTERO;
                case ECConstants.FLOTANTE << 1:
                    return FLOTANTE;
                case ECConstants.CADENA << 1:
                    return CADENA;
                case ECConstants.CARACTER << 1:
                    return CARACTER;
                case ECConstants.CARACTER << 1:
                    return BOOLEANO;
                default:
                    return INDEFINIDO;
            }
        }

        private int _hash;
        private String _nombre;
        private int _dimension;
        private TipoDato _interno;

        private TipoDato(int hash, String nombre, TipoDato interno, int dimension) {
            _hash = hash;
            _nombre = nombre;
            _dimension = dimension;
        }

        private TipoDato(int hash, String nombre) {
            this(hash, nombre, this, 0);
        }

        public String getNombre() {
            return _nombre + "[]".repeat(_dimension);
        }

        public int getDimension() {
            return _dimension;
        }

        public boolean esArreglo(){
            return (_hash & 1) != 0;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            TipoDato tipoDato = (TipoDato) o;
            return _hash == tipoDato._hash && _dimension == tipoDato._dimension;
        }
        @Override
        public int hashCode() {
            return Objects.hash(_hash, _dimension);
        }

        public TipoDato getTipoInterno(){
            return _interno;
        }

        public TipoDato getTipoArreglo(int dimension){

            if (this.equals(INDEFINIDO) || this.equals(VACIO)) return this;

            return new TipoDato(_hash | 1, _nombre, this, dimension);
        }

        public TipoDato getTipoArreglo() {
            return getTipoArreglo(_dimension + 1);
        }

        public boolean puedeUtilizar(int operador) {

            if(esArreglo()) return false;

            boolean eq = false;
            int tipoDato = _hash;

            switch(operador){
                case ECConstants.SUMA:
                    return tipoDato == TIPO_ENTERO || tipoDato == TIPO_FLOTANTE
                    || tipoDato == TIPO_CADENA || tipoDato == TIPO_CARACTER;
                case ECConstants.RESTA:
                case ECConstants.MULTIPLICACION:
                case ECConstants.DIVISION:
                case ECConstants.MODULO:
                    return tipoDato == TIPO_ENTERO || tipoDato == TIPO_FLOTANTE;

                case ECConstants.LOGICO_NOT:
                case ECConstants.LOGICO_OR:
                case ECConstants.LOGICO_AND:
                    return tipoDato == TIPO_BOOLEANO;

                case ECConstants.OPERADOR_IGUAL:
                case ECConstants.OPERADOR_DIFERENTE:
                    eq = tipoDato == TIPO_CADENA || tipoDato == TIPO_BOOLEANO;
                case ECConstants.OPERADOR_MAYOR:
                case ECConstants.OPERADOR_MAYOR_IGUAL:
                case ECConstants.OPERADOR_MENOR:
                case ECConstants.OPERADOR_MENOR_IGUAL:
                    return eq || tipoDato == TIPO_ENTERO || tipoDato == TIPO_FLOTANTE
                        || tipoDato == TIPO_CARACTER;
            }

            return false;
        }

    }

    public abstract class Expresion implements Cloneable {

        private boolean _error;

        public abstract int getTipoExpresion();
        public abstract TipoDato getTipo();

        public final static int EXP_CONSANTE = 1;
        public final static int EXP_VARIABLE = 2;
        public final static int EXP_FUNCION = 3;
        public final static int EXP_INDICE = 4;

        public final static int EXP_SUMA = ECConstants.SUMA;                        // a + b, +a
        public final static int EXP_RESTA = ECConstants.RESTA;                      // a - b, -a
        public final static int EXP_DIVISION = ECConstants.DIVISION;                // a / b
        public final static int EXP_MULTIPLICACION = ECConstants.MULTIPLICACION;    // a * b
        public final static int EXP_MODULO = ECConstants.DIVISION;                  // a % b
        public final static int EXP_MENOR = ECConstants.OPERADOR_MENOR;             // a < b
        public final static int EXP_MENOR_IGUAL = ECConstants.OPERADOR_MENOR_IGUAL; // a <= b
        public final static int EXP_MAYOR = ECConstants.OPERADOR_MAYOR;             // a > b
        public final static int EXP_MAYOR_IGUAL = ECConstants.OPERADOR_MAYOR_IGUAL; // a >= b
        public final static int EXP_IGUAL = ECConstants.OPERADOR_IGUAL;             // a == b
        public final static int EXP_DIFERENTE = ECConstants.OPERADOR_DIFERENTE;     // a != b
        public final static int EXP_ASIGNACION = ECConstants.ASIGNACION;            // a = b
        public final static int EXP_AND = ECConstants.LOGICO_AND;                   // a && b
        public final static int EXP_OR = ECConstants.LOGICO_OR;                     // a || b

        public final static int EXP_NO = ECConstants.LOGICO_NOT;                    // !a

        public boolean esError() {
            return _error;
        }

        public Expresion conError(boolean error) {

            if(_error == error) return this;

            Expresion copy = (Expresion)clone();
            copy.setError(error);

            return copy;
        }

        private void setError(boolean error) {
            _error = error;
        }


        public static Expresion hacerBinaria(int operador, List<Expresion> expresiones) {

            switch(expresiones.size()) {
                case 1:
                    return expresiones.removeFirst();
                case 2:
                    Expresion izq = expresiones.removeFirst();
                    Expresion der = expresiones.removeFirst();
                    return new ExpresionBinaria(operador, izq, der);
                default:
                    Expresion izq = expresiones.removeFirst();
                    Expresion der = hacerBinaria(operador, expresiones);
                    return new ExpresionBinaria(operador, izq, der);

            }

        }

        public static Expresion hacerBinaria(List<Integer> ops, List<Expresion> expresiones) {

            switch(expresiones.size()) {
                case 1:
                    return expresiones.removeFirst();
                case 2:
                    Expresion izq = expresiones.removeFirst();
                    Expresion der = expresiones.removeFirst();
                    return new ExpresionBinaria(ops.removeFirst(), izq, der);
                default:
                    Integer operador = ops.removeFirst();
                    Expresion izq = expresiones.removeFirst();
                    Expresion der = hacerBinaria(ops, expresiones);
                    return new ExpresionBinaria(operador, izq, der);

            }

        }

    }

    public class ExpresionVariable extends Expresion {

        private String _nombre;
        private TipoDato _tipo;

        public ExpresionVariable(String nombre, TipoDato tipo) {
            _nombre = nombre;
            _tipo = tipo;
        }

        public String getNombre(){
            return _nombre;
        }

        public int getTipoExpresion() {
            return Expresion.EXP_VARIABLE;
        }

        public TipoDato getTipo() {
            return _tipo;
        }

    }

    public class ExpresionConstante extends Expresion {

        public final static Expresion ERROR = new ExpresionConstante(null, 0).conError(true);

        private Object _valor;
        private TipoDato _tipo;

        public ExpresionConstante(Object valor, TipoDato tipo) {
            _valor = valor;
            _tipo = tipo;
        }

        public int getTipoExpresion() {
            return Expresion.EXP_CONSANTE;
        }

        public TipoDato getTipo() {
            return _tipo;
        }

        public Object getValor(){
            return _valor;
        }
    }

    public class ExpresionIndice extends Expresion {

        private Expresion _arreglo;
        private List<Expresion> _indices;

        public ExpresionIndice(List<Expresion> indices){
            _indices = Collections.unmodifiableList(indices);
        }

        public Expresion getArreglo() {
            return _arreglo;
        }

        public void setArreglo(Expresion arreglo) {
            _arreglo = arreglo;
        }

        public int getTipoExpresion() {
            return Expresion.EXP_INDICE;
        }

        public TipoDato getTipo() {
            return _arreglo.getTipo().getTipoInterno();
        }

        public List<Expresion> getIndices() {
            return _indices;
        }

        public int getDimension() {
            return _indices.size();
        }

    }

    public class ExpresionFuncion extends Expresion {

        private String _nombre;
        private TipoDato _tipo;
        private List<Expresion> _argumentos;

        public ExpresionFuncion(String nombre, TipoDato tipo, List<Expresion> argumentos) {
            _nombre = nombre;
            _tipo = tipo;
            _argumentos = Collections.unmodifiableList(argumentos);
        }

        public boolean argumentosCompatibles(List<Expresion> argumentos) {

            List<TipoDato> _tiposDato = _argumentos
                                        .stream()
                                        .map(mapper)
                                        .toList();

            List<TipoDato> tiposDato = argumentos
                                        .stream()
                                        .map(mapper)
                                        .toList();

            return _tiposDato.equals(tiposDato);
        }

        public int getTipoExpresion() {
            return Expresion.EXP_FUNCION;
        }

        public TipoDato getTipo() {
            return _tipo;
        }

        public List<Expresion> getArgumetos() {
            return _argumentos;
        }

        public String getNombre() {
            return _nombre;
        }

        private final Function<Expresion, TipoDato> mapper = new Function<Expresion, TipoDato>() {
            @Override
            public TipoDato apply(Expresion e){
                return e.getTipo();
            }
        };

    }

    public class ExpresionBinaria extends Expresion {

        private int _tipoExpresion;
        private Expresion _izq;
        private Expresion _der;
        private TipoDato _tipo;

        public ExpresionBinaria(int tipoExpresion, Expresion izq, Expresion der, TipoDato tipo){
            _tipoExpresion = tipoExpresion;
            _izq = izq;
            _der = der;
            _tipo = tipo;
        }

        public ExpresionBinaria(int tipoExpresion, Expresion izq, Expresion der){
            this(tipoExpresion, izq, der, izq.getTipo());
        }

        public Expresion getIzquierdo(){
            return _izq;
        }

        public Expresion getDerecho(){
            return _der;
        }

        public int getTipoExpresion() {
            return _tipoExpresion;
        }

        public TipoDato getTipo() {
            return _tipo;
        }

    }

    public class ExpresionUnaria extends Expresion {

        private int _tipoExpresion;
        private Expresion _operando;
        private TipoDato _tipo;

        public ExpresionBinaria(int tipoExpresion, Expresion operando, TipoDato tipo){
            _tipoExpresion = tipoExpresion;
            _operando = operando;
            _tipo = tipo;
        }

        public ExpresionBinaria(int tipoExpresion, Expresion operando){
            this(tipoExpresion, operando, operando.getTipo());
        }

        public Expresion getOperando(){
            return _operando;
        }

        public int getTipoExpresion() {
            return _tipoExpresion;
        }

        public TipoDato getTipo() {
            return _tipo;
        }

    }
/*
    public class Expresion {

        public String nombre;

        public int tipoDato;

        public int tipoExpresion = EXP_VARIABLE;

        public Token token;

        public ArrayList<Expresion> expresiones = new ArrayList<Expresion>();

        public boolean isError = false;

        public static final Function<Expresion, Integer> mapper = new Function<Expresion, Integer>() {
            @Override
            public Integer apply(Expresion e){
                return e.tipoDato;
            }
        };

        public static final Predicate<Expresion> errorP = new Predicate<Expresion>() {
             @Override
             public boolean test(Expresion e) {
                 return e.isError;
             }
         };

        public boolean tieneErrores() {

            if (isError) return true;

            return expresiones.stream().anyMatch(Expresion.errorP);
        }

        public static String getTipoDatoNombre(int tipoDato){

            switch (tipoDato){

                case TIPO_VACIO:
                    return "Vacio";
                case TIPO_ENTERO:
                    return "Entero";
                case TIPO_FLOTANTE:
                    return "Flotante";
                case TIPO_CADENA:
                    return "Cadena";
                case TIPO_CARACTER:
                    return "Caracter";
                case TIPO_BOOLEANO:
                    return "Booleano";

                case TIPO_ENTERO | 1:
                    return "Entero[]";
                case TIPO_FLOTANTE | 1:
                    return "Flotante[]";
                case TIPO_CADENA | 1:
                    return "Cadena[]";
                case TIPO_CARACTER | 1:
                    return "Caracter[]";
                case TIPO_BOOLEANO | 1:
                    return "Booleano[]";

            }

            return "Indefinido";
        }

        public static boolean isArreglo(int tipoDato) {
            return (tipoDato & 1) != 0;
        }

        public static boolean puedeOperar(int tipoDato, int operador){

            boolean eq = false;

            switch(operador){
                case ECConstants.SUMA:
                    return tipoDato == TIPO_ENTERO || tipoDato == TIPO_FLOTANTE
                    || tipoDato == TIPO_CADENA || tipoDato == TIPO_CARACTER;
                case ECConstants.RESTA:
                case ECConstants.MULTIPLICACION:
                case ECConstants.DIVISION:
                case ECConstants.MODULO:
                    return tipoDato == TIPO_ENTERO || tipoDato == TIPO_FLOTANTE;

                case ECConstants.LOGICO_NOT:
                case ECConstants.LOGICO_OR:
                case ECConstants.LOGICO_AND:
                    return tipoDato == TIPO_BOOLEANO;

                case ECConstants.OPERADOR_IGUAL:
                case ECConstants.OPERADOR_DIFERENTE:
                    eq = tipoDato == TIPO_CADENA || tipoDato == TIPO_BOOLEANO;
                case ECConstants.OPERADOR_MAYOR:
                case ECConstants.OPERADOR_MAYOR_IGUAL:
                case ECConstants.OPERADOR_MENOR:
                case ECConstants.OPERADOR_MENOR_IGUAL:
                    return eq || tipoDato == TIPO_ENTERO || tipoDato == TIPO_FLOTANTE
                        || tipoDato == TIPO_CARACTER;
            }

            return false;

        }
    }
*/
    public static class Reporte {

        public boolean isError = false;

        public List<String> lineas = new ArrayList<String>();

        public String codigoIntermedio = "";

    }

    private static final Function<String, String> formaLista = new Function<String, String>() {
        @Override
        public String apply(String s){
            return "- " + s;
        }
    };

    private static final Function<String, String> tabMapper = new Function<String, String>() {
        @Override
        public String apply(String s){
            return s.replace("\t", "    ");
        }
    };

    private static final Function<String, Stream<String>> flatMapper = new Function<String, Stream<String>>() {
        @Override
        public Stream<String> apply(String s){
            return Stream.of(s.split("\n"));
        }
    };

    private static final ToIntFunction<String> intMapper = new ToIntFunction<String>() {
        @Override
        public int applyAsInt(String s){
            return s.length();
        }
    };

    private static final Predicate<Field> fieldFilter = new Predicate<Field>() {
        @Override
        public boolean test(Field f){
            return f.getType() == int.class;
        }
    };

    private static final BinaryOperator<String> fieldMarge = new BinaryOperator<String>() {
        @Override
        public String apply(String x, String y){
            return x;
        }
    };

    private static final Function<Field, Integer> keyMapper = new Function<Field, Integer>() {
        @Override
        public Integer apply(Field f) {
            try{
                return f.getInt(null);
            } catch (IllegalAccessException ex) {
                return 0;
            }

        }
    };

    private static final Function<Field, String> valueMapper = new Function<Field, String>() {
        @Override
        public String apply(Field f){
            return f.getName();
        }
    };

    private static final Map<Integer, String> tiposTokens
    = Arrays.stream(ECConstants.class.getDeclaredFields())
                                  .filter(fieldFilter)
                                  .collect(Collectors.toMap(keyMapper, valueMapper, fieldMarge));

    public static Reporte lexica(String archivo) {
        Reporte reporte = new Reporte();

        if (archivo.isBlank()) {
            reporte.lineas.add("ERROR: Debe de ingresar el archivo del c√≥digo fuente.");
            reporte.isError = true;
            return reporte;
        }

        try {

            FileReader sourceFileReader = new FileReader(archivo);

            EC ec = new EC(sourceFileReader);

            reporte.lineas.add("Fase l√©xica: Tipo -> Valor.");

            for(Token token = ec.getNextToken(); token.kind != ECConstants.EOF; token = ec.getNextToken()) {

                String tipo = tiposTokens.get(token.kind);
                reporte.lineas.add(String.format("\t<%s> -> %s", tipo, token.image));

            }

            var errores = ec.tablaErrores;

            if (!errores.isEmpty()){

                reporte.isError = true;
                reporte.lineas.clear();
                String str1 = "encontraron";
                String str2 = "errores";
                int cErrores = errores.size();

                if (cErrores == 1) {
                    str1 = "encontr√≥";
                    str2 = "error";
                }

                reporte.lineas.add(String.format("Se %s %d %s durante la prueba l√©xica:", str1, cErrores, str2));
                reporte.lineas.add(" ");

                var errors = errores.stream()
                                  .map(formaLista)
                                  .flatMap(flatMapper)
                                  .map(tabMapper)
                                  .toList();

                reporte.lineas.addAll(errors);

            }else{
                reporte.lineas.add("Se pas√≥ la prueba l√©xica con √©xito.");
                reporte.lineas.add("No se encontraron errores.");
            }

            return reporte;

        } catch (FileNotFoundException ex) {
            reporte.lineas.add("ERROR: No se encontr√≥ el archivo.");
            reporte.isError = true;
        }

        return reporte;
    }

    public static Reporte semantica(String archivo) {

        Reporte reporte = new Reporte();

        if (archivo.isBlank()) {
            reporte.lineas.add("ERROR: Debe de ingresar el archivo del c√≥digo fuente.");
            reporte.isError = true;
            return reporte;
        }

        try {

            FileReader sourceFileReader = new FileReader(archivo);

            EC ec = new EC(sourceFileReader);

            ec.programa();

            var errores = ec.tablaErrores;

            reporte.codigoIntermedio = ec.codigoIntermedio.toString();

            reporte.lineas.add("Se pas√≥ la prueba sem√°ntica con √©xito.");
            reporte.lineas.add("No se encontraron errores.");

            if (!errores.isEmpty()){

                reporte.isError = true;
                reporte.lineas.clear();
                String str1 = "encontraron";
                String str2 = "errores";
                int cErrores = errores.size();

                if (cErrores == 1) {
                    str1 = "encontr√≥";
                    str2 = "error";
                }

                reporte.lineas.add(String.format("Se %s %d %s durante la prueba sem√°ntica:", str1, cErrores, str2));
                reporte.lineas.add(" ");

                var errors = errores.stream()
                                  .map(formaLista)
                                  .flatMap(flatMapper)
                                  .toList();

                reporte.lineas.addAll(errors);
            }

            return reporte;

        } catch (FileNotFoundException ex) {
            reporte.lineas.add("ERROR: No se encontr√≥ el archivo.");
            reporte.isError = true;
        } catch (ParseException ex) {
            reporte.lineas.clear();
            reporte.lineas.add("Ha ocurrido un error inesperado, intente de nuevo.");
            reporte.isError = true;
        }

        return reporte;

    }

    public static void main(String[] args) {

        String archivo = "";
        String fase = "sem";

        if (args.length != 0) {
            archivo = args[0];
        }

        if (archivo.startsWith("-")) {
            fase = archivo.substring(1);

            if (args.length > 1) {
                archivo = args[1];
            }else{
                archivo = "";
            }

        }

        Reporte reporte = null;

        switch (fase) {
            case "l": // Fase l√©xica
                reporte = lexica(archivo);
                break;
            case "sem": // Fase sem√°ntica
                reporte = semantica(archivo);
                break;
            default: // Fase no definida
                reporte = new Reporte();
                reporte.isError = true;
                reporte.lineas.add("ERROR: Esta fase todav√≠a no est√° implementada.");
                break;
        }

        reporte.lineas = reporte.lineas.stream()
                                .map(tabMapper)
                                .toList();

        int maxLength = reporte.lineas
                               .stream()
                               .mapToInt(intMapper)
                               .max()
                               .orElse(0);

        // Top border
        System.out.print("‚ïî");
        for (int i = 0; i < maxLength + 2; i++) {
            System.out.print("‚ïê");
        }
        System.out.println("‚ïó");

        // Content with side borders
        for (String linea : reporte.lineas) {
            System.out.printf("‚ïë %-" + maxLength + "s ‚ïë\n", linea);
        }

        // Bottom border
        System.out.print("‚ïö");
        for (int i = 0; i < maxLength + 2; i++) {
            System.out.print("‚ïê");
        }
        System.out.println("‚ïù");

        if (reporte.isError) {
            System.exit(-1);
        }

        try  {
            FileOutputStream fos = new FileOutputStream("intermedio.txt", false);
            fos.write(reporte.codigoIntermedio.getBytes());
            System.out.println("Codigo intermedio creado.");
            fos.close();
        } catch (Exception ex) {
            System.out.println("ERROR: No se pudo generar el codigo intermedio.");
        }

        System.exit(0);
    }

    public EC(FileReader fileReader) {
        this((Reader)fileReader);

        token_source.compilador = this;

    }

    private void processError(ParseException ex, String from){

        // Tokens esperados
        StringBuilder expected = new StringBuilder();

        int maxSize = 0;

        for (int i = 0; i < ex.expectedTokenSequences.length; i++) {
            if (maxSize < ex.expectedTokenSequences[i].length) {
                maxSize = ex.expectedTokenSequences[i].length;
            }
            for (int j = 0; j < ex.expectedTokenSequences[i].length; j++) {
                expected.append(tokenImage[ex.expectedTokenSequences[i][j]]).append(' ');
            }

        }

        Token tokenError = ex.currentToken.next;

        // Tokens encontrados
        ArrayList<Token> tokens = new ArrayList<Token>();
        tokens.add(tokenError);

        for (Token t = tokenError; t.next != null; t = t.next) {

            tokens.add(t);
        }

        String[] expecteds = expected.toString().split(" ");

        StringBuilder msg = new StringBuilder();
        msg.append("Error sint√°ctico en ").append(from).append(',')
        .append(" linea ").append(tokenError.endLine).append(", columna ").append(tokenError.endColumn).append('.');

        if (tokens.size() == 1) {

            if(token.kind == ECConstants.CADENA_TEXTO){
                msg.append(String.format("\n\tSe encontr√≥ el s√≠mbolo %s.", tokenImage[token.kind]));
            } else {
                msg.append(String.format("\n\tSe encontr√≥ el s√≠mbolo \"%s\".", token.image));

                if(!tokenImage[tokenError.kind].regionMatches(1, tokenError.image,0,tokenError.image.length()))
                    msg.append(" (").append(tokenImage[tokenError.kind]).append(')').append('.');
            }

        } else {
            msg.append("\n\tSe encontraron los s√≠mbolos:");
            for (Token token : tokens) {

                if(token.kind == ECConstants.CADENA_TEXTO){
                    msg.append(String.format("\n\t\t - %s.", tokenImage[token.kind]));
                } else {
                    msg.append(String.format("\n\t\t - \"%s\".", token.image));

                    if(!tokenImage[token.kind].regionMatches(1, token.image,0,token.image.length()))
                        msg.append(" (").append(tokenImage[token.kind]).append(')').append('.');
                }

            }
        }

        if (expecteds.length == 1){
            msg.append("\n\tSe esperaba ").append(expecteds[0]).append('.');
        } else {
            msg.append("\n\tSe esperaba uno de los siguientes: ");
            for (String e : expecteds) {
                msg.append("\n\t - ").append(e);
            }
        }

        tablaErrores.add(msg.toString());
    }

    private void skipTo(Integer end, Integer... kinds) {

        List<Integer> kindsList = Arrays.asList(kinds);

        HashSet<Integer> cKinds = new HashSet<Integer>(kindsList);
        cKinds.add(end);
        cKinds.add(FIN_FUNCION);
        cKinds.add(FIN);
        cKinds.add(EOF);

        Token oldToken = token;
        boolean sw = true;
        int selectedKind = EC.EOF;

        do {
            token = getNextToken();

            for (Integer kind : cKinds) {
                sw &= token.kind != kind;

                if (!sw) {
                    selectedKind = kind;
                    break;
                }
            }

        } while (sw);

        if (selectedKind != end) {
            token = oldToken;
            jj_kind = selectedKind;
        }

    }

}}

}

PARSER_END(EC)

TOKEN_MGR_DECLS:{
    EC compilador;
}
// Inicio y fin del programa
TOKEN : {

    <INICIO: "Inicio">
    |
    <FIN: "Fin">

}

// Funciones
TOKEN : {

    <COMA: ",">
    |
    <FUNCION: "Funcion" >
    |
    <FIN_FUNCION: "FinFuncion">
    |
    <RETORNAR: "Retornar">
}

// Tipos de dato
TOKEN : {

    <ENTERO: ("Entero" | "entero")>
    |
    <FLOTANTE: ("Flotante" | "flotante")>
    |
    <CADENA: ("Cadena" | "cadena")>
    |
    <CARACTER: ("Caracter" | "caracter")>
    |
    <BOOLEANO: ("Booleano" | "booleano")>
}

// Escritura, Lectura y Definici√≥n de variables
TOKEN : {
    <INTERPRETAR: "Interpretar">
    |
    <ESCRIBIR: "Escribir">
    |
    <ESTABLECER: "Establecer">
}

// Operadores
TOKEN : {
    <ASIGNACION: "=">
    |
    <SUMA: "+">
    |
    <RESTA: "-">
    |
    <MULTIPLICACION: "*">
    |
    <DIVISION: "/">
    |
    <MODULO: "%">
    |
    <LOGICO_AND: "&&">
    |
    <LOGICO_OR: "||">
    |
    <LOGICO_NOT: "!">
    |
    <OPERADOR_IGUAL: "==">
    |
    <OPERADOR_DIFERENTE: "!=">
    |
    <OPERADOR_MAYOR: ">">
    |
    <OPERADOR_MENOR: "<">
    |
    <OPERADOR_MAYOR_IGUAL: ">=">
    |
    <OPERADOR_MENOR_IGUAL: "<=">
    |
    <OPERADOR_DOS_PUNTOS: ":">
    |
    <PAREN_ABIERTO: "(">
    |
    <PAREN_CERRADO: ")">
    |
    <INDICE_ABIERTO: "[">
    |
    <INDICE_CERRADO: "]">
}

// Constantes/Literales
TOKEN : {
    <#LETRA: ["a" - "z", "√±"] | ["A" - "Z", "√ë"]>
    |
    <#NUMERO: ["0" - "9"]>
    |
    <CADENA_TEXTO: "\"" ( ~["\""] )* "\"">
    |
    <CARACTER_TEXTO: "'"( ~["'"] )"'">
    |
    <NUMERO_ENTERO: (<NUMERO>)+>
    |
    <NUMERO_DECIMAL: (<NUMERO>)+"."(<NUMERO>)+>
    |
    <BOOLEANO_FALSO: "Falso">
    |
    <BOOLEANO_VERDADERO: "Verdadero">
    |
    <DELIMITADOR: ";">

}

// Ciclos
TOKEN : {
    <INICIO_CICLO_PARA: "Para">
    |
    <CONDICION_CICLO_PARA: "Hasta que">
    |
    <INCREMENTO_CICLO_PARA: "Con incremento">
    |
    <FIN_CICLO_PARA: "FinPara">
    |
    <INICIO_CICLO_MIENTRAS: "Mientras">
    |
    <FIN_CICLO_MIENTRAS: "FinMientras">
    |
    <INICIO_CICLO_REPETIR: "Repetir">
    |
    <CONDICION_CICLO_REPETIR: "Finaliza cuando">
}

// Condicionales
TOKEN : {
    <INICIO_CONDICIONAL_SI:"Si">
    |
    <ENTONCES:"Entonces">
    |
    <CONDICIONAL_SINO:"Sino">
    |
    <FIN_CONDICIONAL_SI:"FinSi">
    |
    <INICIO_CONDICIONAL_CONFORME:"Conforme">
    |
    <CASO:"Caso">
    |
    <CASO_PREDETERMINADO:"En otro caso">
    |
    <FIN_CONFORME:"FinConforme">
    |
    <HACER : "Hacer">
}

//Variables
TOKEN : {
    <VARIABLE:(<LETRA> | "_")(<NUMERO> | <LETRA> | "_")*>
}

SKIP : {
    " "
    | "\t"
    | "\r\n"
    | "\n"
    | <COMENTARIO: "#" (~["\r", "\n"])* ( ( "\r" )? "\n" | "\r")>

}

// Tokens invalidos
TOKEN : {

    <NUMERO_INVALIDO: (<NUMERO>)*("."( <NUMERO> | <LETRA> )* | <LETRA>)+>{

        compilador.tablaErrores.add("Error l√©xico, l√≠nea "
                        + matchedToken.beginLine + ", columna " + matchedToken.beginColumn
                        + ".\n\tSe encontr√≥ un n√∫mero inv√°lido '" + matchedToken.image + "'."
                        + "\n\tPosible soluci√≥n: Remover o revisar n√∫mero.");

    }
    | <INVALIDO: ~[]>{

        compilador.tablaErrores.add("Error l√©xico, l√≠nea " +
                     matchedToken.beginLine + ", columna " + matchedToken.beginColumn +
                     ".\nSe encontr√≥ s√≠mbolo inv√°lido '" + matchedToken.image + "'." +
                     "\n\tPosible soluci√≥n: Remover s√≠mbolo.");

    }

}

// Gramaticas

List<Expresion> argumentos(Ambito ambito) :
{
    Expresion exp;
    List<Expresion> argumentos = new ArrayList<Integer>();
}
{
    exp = expresion(ambito)
    {
        argumentos.add(exp);
    }
    (
        <COMA>
        exp = expresion(ambito)
        {
            argumentos.add(exp);
        }
    )*
    {
        return argumentos;
    }
}

ArrayList<Expresion> declaracionArgumentos(Ambito ambito) :
{
    Expresion argumento = new Expresion();
    ArrayList<Expresion> argumentos = new ArrayList<Expresion>();
} {
    argumento.tipoDato = tiposDato()
    <VARIABLE>
    {

        if(ambito.tablaSimbolos.containsKey(token.image)){

            tablaErrores.add("Error sem√°ntico, L√≠nea " + token.beginLine + ", columna " + token.beginColumn
                           + ".\n\tEl s√≠mbolo \"" + token.image + "\" ya est√° declarado en este √°mbito." +
                             "\n\tQuitar declaraci√≥n doble.");

            argumento.isError = true;
        }

        argumento.token = token;
        argumento.nombre = token.image;

        if(!argumento.tieneErrores()){
            ambito.tablaSimbolos.put(argumento.nombre, argumento);
        }

        argumentos.add(argumento);

    }
    (
        <COMA>
        {
            argumento = new Expresion();
        }
        argumento.tipoDato = tiposDato()
        <VARIABLE>
        {

            if(ambito.tablaSimbolos.containsKey(token.image)){

                tablaErrores.add("Error sem√°ntico, L√≠nea " + token.beginLine + ", columna " + token.beginColumn
                               + ".\n\tEl s√≠mbolo \"" + token.image + "\" ya est√° declarado en este √°mbito." +
                                 "\n\tQuitar declaraci√≥n doble.");

                argumento.isError = true;
            }

            argumento.token = token;
            argumento.nombre = token.image;

            if(!argumento.tieneErrores()){
                ambito.tablaSimbolos.put(argumento.nombre, argumento);
            }

            argumentos.add(argumento);
        }
    )*
    {
        return argumentos;
    }
}

void declaracionFuncion(Ambito ambito) :
{
    int tipoDato;
    Expresion funcion = new Expresion();
    funcion.tipoExpresion = EXP_FUNCION;
    funcion.tipoDato = TIPO_VACIO;

    Ambito ambitoFuncion = new Ambito();
}{
    <FUNCION> ( funcion.tipoDato = tiposDato() )?
    <VARIABLE>
    {

        if (ambito.tablaSimbolos.containsKey(token.image)) {

            tablaErrores.add("Error sem√°ntico, L√≠nea " + token.beginLine + ", columna " + token.beginColumn
                           + ".\n\tEl s√≠mbolo \"" + token.image + "\" ya est√° declarado en este √°mbito." +
                             "\n\tQuitar declaraci√≥n doble.");

            funcion.isError = true;
        }

        funcion.nombre = token.image;
        funcion.token = token;
        ambitoFuncion.tablaSimbolos.put(funcion.nombre, funcion);

        if (!funcion.tieneErrores()) {
            ambito.tablaSimbolos.put(funcion.nombre, funcion);
        }

    }
     <PAREN_ABIERTO> ( funcion.expresiones = declaracionArgumentos(ambitoFuncion) )? <PAREN_CERRADO>
    ( sentencias(ambitoFuncion) )*
    (
        <RETORNAR>
        tipoDato = expresion(ambitoFuncion)
        <DELIMITADOR>
        {

            if (!funcion.tieneErrores() && funcion.tipoDato == TIPO_VACIO) {

                tablaErrores.add("Error sem√°ntico, L√≠nea " + token.beginLine + ", columna " + token.beginColumn
                               + ".\n\tLa funci√≥n \"" + funcion.nombre + "\" no puede retornar ningun valor."
                               + "\n\tQuitar retornar.");

                funcion.isError = true;

            }

            if (!funcion.tieneErrores() && funcion.tipoDato != tipoDato) {

                tablaErrores.add("Error sem√°ntico, L√≠nea " + token.beginLine + ", columna " + token.beginColumn
                               + ".\n\tLa funci√≥n \"" + funcion.nombre + "\" no puede retornar un tipo de dato \""
                               +  Expresion.getTipoDatoNombre(tipoDato) + "\"."
                               + "\n\tRetornar tipo de dato \"" + Expresion.getTipoDatoNombre(funcion.tipoDato) + "\"." );

                funcion.isError = true;

            }

        }
    )?
    <FIN_FUNCION> <VARIABLE>
    {
        if(!funcion.nombre.equals(token.image)){

            tablaErrores.add("Error sem√°ntico, L√≠nea " + token.beginLine + ", columna " + token.beginColumn
                           + ".\n\tLa funci√≥n debe de terminar con el mismo nombre."
                           + "\n\tColocar el nombre de la funci√≥n despu√©s del FinFuncion.");

            if (!funcion.tieneErrores()) {
                ambito.tablaSimbolos.remove(funcion.nombre);
            }

            funcion.isError = true;


        }
    }
}

void programa():
{
    Ambito ambitoPrincipal = new Ambito();
}{

    try {
        // Nuevo
        ( declaracionFuncion(ambitoPrincipal) )*
        <INICIO> ( sentencias(ambitoPrincipal) )+ <FIN>
        <EOF>

        // Eliminado
        // <INICIO> ( sentencias() )+ <FIN><EOF>
    } catch (ParseException ex){

        processError(ex, "programa principal");

        skipTo(FIN_FUNCION);
    }
}

void sentencias(Ambito ambito):{ }{

    sentenciaDeclaracion(ambito) |
    sentenciaAsignacion(ambito) |
    leerDato(ambito) |
    imprimirDato(ambito) |
    sentenciaSi(ambito) |
    sentenciaConforme(ambito) |
    sentenciaPara(ambito) |
    sentenciaRepetir(ambito) |
    sentenciaMientras(ambito)

}

void sentenciaAsignacion(Ambito ambito) :
{
    Tupla<Integer, Token> tupla;
    Expresion exp;
} {

    try {
        exp = llamadas(ambito)
        ( asignacion(ambito, tupla) )?
        <DELIMITADOR>
    } catch (ParseException ex) {

        processError(ex, "sentencia de asignacion");

        skipTo(DELIMITADOR, SENTENCES_BEGIN);

    }

}

void sentenciaDeclaracion(Ambito ambito) : { } {

    try {
        declaracion(ambito) <DELIMITADOR>
    } catch (ParseException ex) {

        processError(ex, "sentencia de declaraci√≥n");

        skipTo(DELIMITADOR, SENTENCES_BEGIN);

    }
}

TipoDato tiposDato() : { } {
    ( <ENTERO>
    |
    <FLOTANTE>
    |
    <CADENA>
    |
    <CARACTER>
    |
    <BOOLEANO> ) { return TipoDato.desdeTipo(token.kind << 1); }
}

Expresion constantes(): { }{

    <NUMERO_ENTERO>
    {
        return new ExpresionConstante(Integer.parseInt(token.image), TipoDato.ENTERO);
    }   // 2
    |
    <NUMERO_DECIMAL>
    {
        return new ExpresionConstante(Double.parseDouble(token.image), TipoDato.FLOTANTE);
    }   // 2.3 0.0
    |
    <CADENA_TEXTO>
    {
        int fin = token.image.length() - 1;
        String str = token.image;
        return new ExpresionConstante(str.substring(1, fin), TipoDato.CADENA);
    }   // "Hola"
    |
    <CARACTER_TEXTO>
    {
        int fin = token.image.length() - 1;
        String str = token.image;

        return new ExpresionConstante(str.substring(1, fin).charAt(0), TipoDato.CARACTER);
    }  // 'c'
    |
    <BOOLEANO_FALSO>
    {
        String str = token.image;
        return new ExpresionConstante(!str.equalsIgnoreCase("falso"), TipoDato.BOOLEANO);
    } // Falso
    |
    <BOOLEANO_VERDADERO>
    {
        String str = token.image;
        return new ExpresionConstante(str.equalsIgnoreCase("verdadero"), TipoDato.BOOLEANO);
    }   // Verdadero
}

void asignacion(Ambito ambito, Expresion exp) :
{
    boolean error = exp.esError();
    String nombre;

    if (exp instanceof ExpresionVariable) {
        ExpresionVariable ev = (ExpresionVariable)exp;
        nombre = ev.getNombre();
    }

    if (!error && !ambito.tablaSimbolos.containsKey(nombre)) {

        tablaErrores.add("Error sem√°ntico, L√≠nea " + token.beginLine + ", columna " + token.beginColumn
                        + ".\n\tEl s√≠mbolo \"" + token.image + "\" no est√° declarado en este √°mbito." +
                         "\n\tDeclarar el s√≠mbolo.");

        error = true;
    }

    Expresion exp = ambito.tablaSimbolos.get(tk.image);

    if(!error && !exp.tieneErrores() && exp.tipoExpresion == EXP_FUNCION) {

        tablaErrores.add("Error sem√°ntico, L√≠nea " + tk.beginLine + ", columna " + tk.beginColumn
                        + ".\n\t\""+ exp.nombre +"\" no es un s√≠mbolo asignable." +
                          "\n\tNo se le puede asignar un valor a una llamada de funci√≥n.");

        error = true;
    }

    int tipoDato;
} {
    <ASIGNACION> tipoDato = expresion(ambito)
    {
        if(tipoDato == 0) {
            error = true;
        }

        int expTipoDato = t.getPrimero();
        if(expTipoDato == -2){
            expTipoDato = exp.tipoDato;
        }

        if(!error && !exp.tieneErrores() && expTipoDato != tipoDato){
            Token token = exp.token;
            tablaErrores.add("Error sem√°ntico, L√≠nea " + token.beginLine + ", columna " + token.beginColumn
                           + ".\n\tNo se puede asignar un tipo de dato \"" + Expresion.getTipoDatoNombre(tipoDato)
                           + "\" a un tipo de dato \"" +  Expresion.getTipoDatoNombre(exp.tipoDato) + "\"."
                           + "\n\tSe esperaba tipo de dato \"" +  Expresion.getTipoDatoNombre(exp.tipoDato) + "\".");

        }

    }
}

Expresion expresion(Ambito ambito):
{
    Expresion expresion;
}
{
    expresion = logicoOr(ambito) { return expresion; }
}

Expresion logicoOr(Ambito ambito) :
{
    Expresion izq;
    Expresion der;

    List<Expresion> exps = new ArrayList<Expresion>();

    Token op;
    boolean error = false;
}{
    izq = logicoAnd(ambito)
    {
        error = izq.esError();

        exps.add(izq);

    }
    ( <LOGICO_OR> { op = token; }
        der = logicoAnd(ambito)
        {

            if (!error &&
                (!izq.getTipo().equals(der.getTipo()) ||
                !izq.getTipo().puedeUtilizar(op.kind) || !der.getTipo().puedeUtilizar(op.kind))) {

                tablaErrores.add("Error sem√°ntico, L√≠nea " + op.beginLine + ", columna " + op.beginColumn
                                + ".\n\tNo se puede aplicar el operador '" + op.image +  "' entre tipos de dato \"" +
                                 izq.getTipo().getNombre() + "\" y \"" + der.getTipo().getNombre() + "\".");

                error = true;

            }

            exps.add(der);

        }
    )*
    {
        return Expresion.hacerBinaria(op.kind, exps).conError(error);
    }
}

Expresion logicoAnd(Ambito ambito) :
{
    Expresion izq;
    Expresion der;

    List<Expresion> exps = new ArrayList<Expresion>();

    Token op;
    boolean error;
}{
    izq = comparacion(ambito)
    {
        error = izq.esError();

        exps.add(izq);
    }
    ( <LOGICO_AND> { op = token; }
        der = comparacion(ambito)
        {
            if (!error &&
                (!izq.getTipo().equals(der.getTipo()) ||
                !izq.getTipo().puedeUtilizar(op.kind) || !der.getTipo().puedeUtilizar(op.kind))) {

                tablaErrores.add("Error sem√°ntico, L√≠nea " + op.beginLine + ", columna " + op.beginColumn
                                + ".\n\tNo se puede aplicar el operador '" + op.image +  "' entre tipos de dato \"" +
                                 izq.getTipo().getNombre() + "\" y \"" + der.getTipo().getNombre() + "\".");

                error = true;

            }

            exps.add(der);

       }
    )*
    {
        return Expresion.hacerBinaria(op.kind, exps).conError(error);
    }
}

Expresion comparacion(Ambito ambito) :
{
    Expresion izq;
    Expresion der;

    Token op;

    boolean error;
    boolean sw = false;
}
{
    izq = operando(ambito)
    {
        error = izq.esError();
    }
    ( ( <OPERADOR_IGUAL> | <OPERADOR_DIFERENTE> | <OPERADOR_MAYOR_IGUAL> | <OPERADOR_MENOR_IGUAL> | <OPERADOR_MAYOR> | <OPERADOR_MENOR> ) { op = token; }
        der = operando(ambito)
        {

            if (!error &&
                (!izq.getTipo().equals(der.getTipo()) ||
                !izq.getTipo().puedeUtilizar(op.kind) || !der.getTipo().puedeUtilizar(op.kind))) {

                tablaErrores.add("Error sem√°ntico, L√≠nea " + op.beginLine + ", columna " + op.beginColumn
                                + ".\n\tNo se puede aplicar el operador '" + op.image +  "' entre tipos de dato \"" +
                                 izq.getTipo().getNombre() + "\" y \"" + der.getTipo().getNombre() + "\".");

                error = true;

            }

            sw = true;

       }
    )?
    {
        if (!sw) return izq.conError(error);

        return new ExpresionBinaria(op.kind, izq, der, TipoDato.BOOLEANO).conError(error);
    }
}

Expresion operando(Ambito ambito) :
{
    Expresion izq;
    Expresion der;


    List<Integer> ops = new ArrayList<Integer>();
    List<Expresion> exps = new ArrayList<Expresion>();

    Token op;
    boolean error;
}{
    izq = termino(ambito)
    {
        error = izq.esError();

        exps.add(izq);
    }
    ( ( <RESTA> | <SUMA> )
        {
            op = token;

            ops.add(op.kind);
        }
        der = termino(ambito)
        {
            if (!error &&
                (!izq.getTipo().equals(der.getTipo()) ||
                !izq.getTipo().puedeUtilizar(op.kind) || !der.getTipo().puedeUtilizar(op.kind))) {

                tablaErrores.add("Error sem√°ntico, L√≠nea " + op.beginLine + ", columna " + op.beginColumn
                                + ".\n\tNo se puede aplicar el operador '" + op.image +  "' entre tipos de dato \"" +
                                 izq.getTipo().getNombre() + "\" y \"" + der.getTipo().getNombre() + "\".");

                error = true;

            }

            exps.add(der);

       }
    )*
    {
        return Expresion.hacerBinaria(ops, exps).conError(error);
    }
}

Expresion termino(Ambito ambito):
{
    Expresion izq;
    Expresion der;

    List<Integer> ops = new ArrayList<Integer>();
    List<Expresion> exps = new ArrayList<Expresion>();

    Token op;
    boolean error;
}{
    izq = factor(ambito)
    {
        error = izq.esError();

        exps.add(izq);

    }
    ( ( <MULTIPLICACION> | <DIVISION> | <MODULO> )
       {
            op = token;

            ops.add(op.kind);
       }
       der = factor(ambito)
       {

            if (!error &&
                (!izq.getTipo().equals(der.getTipo())
                || !izq.getTipo().puedeUtilizar(op.kind) || !der.getTipo().puedeUtilizar(op.kind))) {

                tablaErrores.add("Error sem√°ntico, L√≠nea " + op.beginLine + ", columna " + op.beginColumn
                                + ".\n\tNo se puede aplicar el operador '" + op.image +  "' entre tipos de dato \"" +
                                 izq.getTipo().getNombre() + "\" y \"" + der.getTipo().getNombre() + "\".");

                error = true;

            }

            exps.add(der);

       }
    )*
    {
        return Expresion.hacerBinaria(ops, exps).conError(error);
    }
}

Expresion factor(Ambito ambito) :
{
    Expresion exp;
    Token op;
} {

    exp = llamadas(ambito) { return exp; }
    |
    exp = constantes()
    {
        return exp;
    }
    |
    <PAREN_ABIERTO> exp = expresion(ambito) <PAREN_CERRADO> { return exp; }
    |
    <LOGICO_NOT> { op = token; } exp = factor(ambito)
    {
        Expresion unario = new ExpresionUnaria(op.kind, exp, TipoDato.BOOLEANO);

        if (!exp.getTipo().puedeUtilizar(op.kind)) {

            tablaErrores.add("Error sem√°ntico, L√≠nea " + op.beginLine + ", columna " + op.beginColumn
                            + ".\n\tNo se puede aplicar el operador '" + op.image +  "' en tipo de dato \"" +
                             exp.getTipo().getNombre() + "\".");

            return unario.conError(true);
        }

        return unario;
    }
    |
    (<SUMA> | <RESTA> ) { op = token; } exp = factor(ambito)
    {

        Expresion unario = new ExpresionUnaria(op.kind, exp);

        if (!exp.getTipo().puedeUtilizar(op.kind)) {

            tablaErrores.add("Error sem√°ntico, L√≠nea " + op.beginLine + ", columna " + op.beginColumn
                        + ".\n\tNo se puede aplicar el operador '" + op.image +  "' en tipo de dato \"" +
                         exp.getTipo().getNombre() + "\".");

            return unario.conError(true);
        }

        return unario;
    }

}

Expresion llamadas(Ambito ambito) :
{
    Expresion exp = null;
    boolean error = false;

    Token v;
} {
    v = <VARIABLE>
    {

        if (!ambito.tablaSimbolos.containsKey(v.image)) {

            tablaErrores.add("Error sem√°ntico, L√≠nea " + v.beginLine + ", columna " + v.beginColumn
                            + ".\n\tEl s√≠mbolo \"" + v.image + "\" no est√° declarado en este √°mbito." +
                             "\n\tDeclarar el s√≠mbolo.");
            error = true;
        }

        if (!error) {
            exp = ambito.tablaSimbolos.get(v.image);
        }

    }
    (
        {
            ExpresionIndice indice;
        }
        indice = indiceArreglo(ambito)
        {
            // Comprobar que sean de la misma dimensi√≥n
            if (!error) {

                if (!exp.getTipo().esArreglo()) {

                    tablaErrores.add("Error sem√°ntico, L√≠nea " + v.beginLine + ", columna " + v.beginColumn
                                   + ".\n\tEl s√≠mbolo \"" + v.image + "\" no es un arreglo.");

                    error = true;

                } else if (indice.getDimension() != exp.getTipo().getDimension()) {

                    tablaErrores.add("Error sem√°ntico, L√≠nea " + v.beginLine + ", columna " + v.beginColumn
                                   + ".\n\tLa dimensi√≥n del arreglo con coincide con la cantidad de √≠ndices.");

                    error = true;

                }

            }

            indice.setArreglo(exp);
            return indice.conError(error);
        }
        |
        {
            List<Expresion> args = new ArrayList<Expresion>();
        }
        <PAREN_ABIERTO> ( args = argumentos(ambito) )? <PAREN_CERRADO>
        {
            if (!error && exp.getTipoExpresion() != Expresion.EXP_FUNCION) {

                tablaErrores.add("Error sem√°ntico, L√≠nea " + v.beginLine + ", columna " + v.beginColumn
                               + ".\n\tEl s√≠mbolo \"" + v.image + "\" no es una funci√≥n.");

                error = true;
            }

            if (!error) {

                ExpresionFuncion ef = (ExpresionFuncion)exp;

                if (!ef.argumentosCompatibles(args)) {

                    tablaErrores.add("Error sem√°ntico, L√≠nea " + v.beginLine + ", columna " + v.beginColumn
                                   + ".\n\tLos argumentos proporcionados no coinciden con los de la funci√≥n.");

                    error = true;

                }

            }

        }
    )?
    {
        return error ? ExpresionContante.ERROR : exp;
    }
}

ExpresionIndice indiceArreglo(Ambito ambito) :
{
    Expresion exp;

    List<Expresion> exps = new ArrayList<Expresion>();
    boolean error = arreglo == null;
}{
    (
        <INDICE_ABIERTO>
        exp = expresion(ambito)
        <INDICE_CERRADO>
        {
            if (!error && !exp.getTipo().equals(TipoDato.ENTERO)) {

                tablaErrores.add("Error sem√°ntico, L√≠nea " + token.beginLine + ", columna " + token.beginColumn
                                + ".\n\tEl tama√±o o el indice de un arreglo debe ser un entero.");

                error = true;
            }

            exps.add(exp);

        }
    )+
    {

        return new ExpresionIndice(exps).conError(error);
    }
}

void declaracion(Ambito ambito) :
{

    TipoDato tipo;
    boolean error = false;

    ExpresionVariable variable;
} {
    <ESTABLECER> tipo = tiposDato()
    (
        {
            ExpresionIndice indice;
        }
        indice = indiceArreglo(ambito)
        {
            tipo = tipo.getTipoArreglo(indice.getDimension());
        }
    )?
    <VARIABLE>
    {

        if (ambito.tablaSimbolos.containsKey(token.image)){

            tablaErrores.add("Error sem√°ntico, L√≠nea " + token.beginLine + ", columna " + token.beginColumn
                            + ".\n\tEl s√≠mbolo \"" + token.image + "\" ya est√° declarado en este √°mbito." +
                             "\n\tQuitar declaraci√≥n doble.");

            error = true;

        } else {
            String nombre = token.image;

            variable = new ExpresionVariable(nombre, tipo);
            ambito.tablaSimbolos.put(nombre, variable);
        }

    }
    ( asignacion(ambito, variable) )?

}

void leerDato(Ambito ambito) : { } {

    try {
        <INTERPRETAR>
        <VARIABLE>
        {
            if (!ambito.tablaSimbolos.containsKey(token.image)){

                tablaErrores.add("Error sem√°ntico, L√≠nea " + token.beginLine + ", columna " + token.beginColumn
                               + ".\n\tEl s√≠mbolo \"" + token.image + "\" no est√° declarado en este √°mbito."
                               + "\n\tDeclare una variable para asignarle un valor.");

            }
        }
         <DELIMITADOR>
    } catch (ParseException ex) {

        processError(ex, "sentencia de lectura de dato");

        skipTo(DELIMITADOR, SENTENCES_BEGIN);

    }
}

void imprimirDato(Ambito ambito):{}{

    try {
        <ESCRIBIR> expresion(ambito) <DELIMITADOR>
    } catch (ParseException ex) {

        processError(ex, "sentencia de escritura de dato");

        skipTo(DELIMITADOR, SENTENCES_BEGIN);

    }

}

void sentenciaSi(Ambito ambito) :
{
    Ambito ambitoSi = new Ambito(ambito);
} {

    try {
        <INICIO_CONDICIONAL_SI> expresion(ambito) <ENTONCES> ( sentencias(ambitoSi) )*
        (
            <CONDICIONAL_SINO>
            {
                ambitoSi = new Ambito(ambito);
            }
            ( sentencias(ambitoSi) )*
        )?
        <FIN_CONDICIONAL_SI>
    } catch (ParseException ex) {

        processError(ex, "sentencia condicional Si");

        skipTo(FIN_CONDICIONAL_SI);

    }

}

void sentenciaConforme(Ambito ambito) :
{
    boolean error = false;
    int tipoDatoCaso;
    Expresion exp = null;
    Ambito ambitoConforme;
    HashSet<String> casos = new HashSet<String>();
} {

    try {
        <INICIO_CONDICIONAL_CONFORME>
        <VARIABLE>
        {
            if (!ambito.tablaSimbolos.containsKey(token.image)) {

                tablaErrores.add("Error sem√°ntico, L√≠nea " + token.beginLine + ", columna " + token.beginColumn
                               + ".\n\tEl s√≠mbolo \"" + token.image + "\" no est√° declarado en este √°mbito."
                               + "\n\tDeclare una variable para asignarle un valor.");

                error = true;

            }

            if (!error) {
                exp = ambito.tablaSimbolos.get(token.image);

                if (exp.tipoExpresion != EXP_VARIABLE) {

                    tablaErrores.add("Error sem√°ntico, L√≠nea " + token.beginLine + ", columna " + token.beginColumn
                                   + ".\n\tLa sentencia \"Segun\" solo funciona con variables.");

                    error = true;

                }

            }

        }
        <HACER>
        (
            <CASO>
            tipoDatoCaso = constantes()
            {

                if (!error && exp.tipoDato != tipoDatoCaso){

                    tablaErrores.add("Error sem√°ntico, L√≠nea " + token.beginLine + ", columna " + token.beginColumn
                                   + ".\n\tTipo de dato del caso err√≥neo."
                                   + "\n\tEl caso debe tener un valor constante \"" + Expresion.getTipoDatoNombre(exp.tipoDato)  +"\".");

                    error = true;
                }

                if(!error && !casos.add(token.image)){

                    tablaErrores.add("Error sem√°ntico, L√≠nea " + token.beginLine + ", columna " + token.beginColumn
                                   + ".\n\tEl caso \"" + token.image + "\" ya existe."
                                   + "\n\tElimine caso repetido.");
                }

                ambitoConforme = new Ambito(ambito);
            }
            <OPERADOR_DOS_PUNTOS>
            ( sentencias(ambitoConforme) )*
        )+
        ( <CASO_PREDETERMINADO> <OPERADOR_DOS_PUNTOS> ( sentencias(ambitoConforme) )* )?
        <FIN_CONFORME>
    } catch (ParseException ex) {

        processError(ex, "sentencia condicional Conforme");

        skipTo(FIN_CONFORME);

    }

}

void sentenciaPara(Ambito ambito) :
{
    Ambito ambitoPara = new Ambito(ambito);
} {

    try {
        <INICIO_CICLO_PARA> ( <VARIABLE> asignacion(ambito, new Tupla<Integer, Token>(-2, token) ) | declaracion(ambitoPara) )
        <CONDICION_CICLO_PARA> expresion(ambitoPara) <INCREMENTO_CICLO_PARA> ( <NUMERO_ENTERO> | <NUMERO_DECIMAL> )
        ( sentencias(ambitoPara) )*
        <FIN_CICLO_PARA>
    } catch (ParseException ex) {

        processError(ex, "sentencia de bucle Para");

        skipTo(FIN_CICLO_PARA);

    }


}

void sentenciaRepetir(Ambito ambito) :
{
    Ambito ambitoRepetir = new Ambito(ambito);
} {

    try {
        <INICIO_CICLO_REPETIR> ( sentencias(ambitoRepetir) )*
        <CONDICION_CICLO_REPETIR> expresion(ambito) <DELIMITADOR>
    } catch (ParseException ex) {

        processError(ex, "sentencia de bucle Repetir");

        skipTo(DELIMITADOR, SENTENCES_BEGIN);

    }

}

void sentenciaMientras(Ambito ambito) :
{
    Ambito ambitoMientras = new Ambito(ambito);
} {

    try {
        <INICIO_CICLO_MIENTRAS> expresion(ambito) <HACER>
        ( sentencias(ambitoMientras) )*
        <FIN_CICLO_MIENTRAS>
    } catch (ParseException ex) {

        processError(ex, "sentencia de bucle Mientras");

        skipTo(FIN_CICLO_MIENTRAS);

    }


}