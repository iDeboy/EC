
options {
    STATIC = false;
}

PARSER_BEGIN(EC)

    import java.io.*;
    import java.util.*;

    public class EC {

        final Integer[] SENTENCES_BEGIN = new Integer[]
                {VARIABLE, ESTABLECER, INTERPRETAR, ESCRIBIR, INICIO_CONDICIONAL_SI, INICIO_CONDICIONAL_CONFORME,
                INICIO_CICLO_PARA, INICIO_CICLO_REPETIR, INICIO_CICLO_MIENTRAS};

        final ArrayList<String> tablaErrores = new ArrayList<String>();
        final HashMap<String, Token> tablaSimbolos = new HashMap<String, Token>();

        public static void main(String[] args) {

            if (args.length == 0) {
                System.err.println("ERROR: Debe de ingresar el archivo del código fuente.");
                System.exit(-1);
                return;
            }

            try {
                FileReader sourceFileReader = new FileReader(args[0]);

                EC ec = new EC(sourceFileReader);

                ec.programa();

                var errores = ec.tablaErrores;

                System.out.println("----------------------------------------------");

                if(errores.isEmpty()){
                    System.out.println("Se pasó la prueba sintáctica con éxito.\nNo se encontraron errores.");
                    System.out.println("----------------------------------------------");
                    System.exit(0);
                }

                if (errores.size() == 1) {
                    System.err.println("Se encontró " + errores.size() + " error durante la prueba sintáctica:");
                } else {
                    System.err.println("Se encontraron " + errores.size() + " errores durante la prueba sintáctica:");
                }

                System.out.println();

                for (String error : errores) {
                    System.err.println(error);
                }

                System.out.println("----------------------------------------------");
                System.exit(-1);

            } catch (FileNotFoundException ex) {
                System.err.println("No se encontró el archivo.");
                System.exit(-1);
            }catch (ParseException ex) {
                 System.err.println("Ha ocurrido un error inesperado, intente de nuevo.");
                 System.exit(-1);
            }

        }

        public EC(FileReader fileReader) {
            this((Reader)fileReader);

            token_source.compilador = this;

        }

        private void processError(ParseException ex, String from){

            // Tokens esperados
            StringBuilder expected = new StringBuilder();
            int maxSize = 0;

            for (int i = 0; i < ex.expectedTokenSequences.length; i++) {
                if (maxSize < ex.expectedTokenSequences[i].length) {
                    maxSize = ex.expectedTokenSequences[i].length;
                }
                for (int j = 0; j < ex.expectedTokenSequences[i].length; j++) {
                    expected.append(ex.tokenImage[ex.expectedTokenSequences[i][j]]).append(' ');
                }

            }

            Token t = ex.currentToken;

            // Tokens encontrados
            StringBuilder found = new StringBuilder();
            Token tok = t.next;

            for (int i = 0; i < maxSize; i++) {

                if (i != 0) found.append(" ");

                if (tok.kind == 0) {
                    found.append(tokenImage[0]);
                    break;
                }

                found.append(tokenImage[tok.kind]);

                tok = tok.next;
            }

            String[] founds = found.toString().split(" ");
            String[] expecteds = expected.toString().split(" ");

            StringBuilder msg = new StringBuilder();
            msg.append("Error sint\u00e1ctico en ").append(from).append('.');
            msg.append("\nL\u00ednea ").append(t.beginLine).append(", Columna ").append(t.beginColumn).append('.');

            if (founds.length == 1) {
                msg.append("\nSe encontr\u00f3 el s\u00edmbolo ").append(founds[0]).append('.');
            } else {
                msg.append("\nSe encontraron los s\u00edmbolos:");
                for (String f : founds) {
                    msg.append("\n\t - ").append(f);
                }
            }

            if (expecteds.length == 1){
                msg.append("\nSe esperaba ").append(expecteds[0]).append('.');
            } else {
                msg.append("\nSe esperaba uno de los siguientes: ");
                for (String e : expecteds) {
                    msg.append("\n\t - ").append(e);
                }
            }

            tablaErrores.add(msg.toString());
        }

        private void skipTo(Integer end, Integer... kinds){

            List<Integer> kindsList = Arrays.asList(kinds);

            HashSet<Integer> cKinds = new HashSet<Integer>(kindsList);
            cKinds.add(end);
            cKinds.add(FIN_FUNCION);
            cKinds.add(EOF);

            Token oldToken = token;
            boolean sw = true;
            int selectedKind = EC.EOF;

            do {
                token = getNextToken();

                for (Integer kind : cKinds) {
                    sw &= token.kind != kind;

                    if (!sw) {
                        selectedKind = kind;
                        break;
                    }
                }

            } while (sw);

            if (selectedKind != end) {
                token = oldToken;
                jj_kind = selectedKind;
            }

        }

    }

PARSER_END(EC)

TOKEN_MGR_DECLS:{
    EC compilador;
}

/*
*
* Funcion Main()
*
*   Establecer Entero r = Suma(5,6);
*
* FinFuncion Main
*
* Funcion Entero Suma(Entero x, Entero y)
*   Retornar x + y;
* FinFuncion Suma
*
* */

// Inicio y fin del programa
TOKEN : {

    // Eliminado
    <INICIO: "Inicio">
    |
    // Eliminado
    <FIN: "Fin">

}

// Nuevo
// Funciones
TOKEN : {

    <COMA: ",">
    |
    <FUNCION: "Funcion" >
    |
    <FIN_FUNCION: "FinFuncion">
}

// Tipos de dato
TOKEN : {

    <ENTERO: ("Entero" | "entero")>
    |
    <FLOTANTE: ("Flotante" | "flotante")>
    |
    <CADENA: ("Cadena" | "cadena")>
    |
    <CARACTER: ("Caracter" | "caracter")>
    |
    <BOOLEANO: ("Booleano" | "booleano")>
}

// Constantes/Literales
TOKEN : {
    <#LETRA: ["a" - "z", "ñ"] | ["A" - "Z", "Ñ"]>
    |
    <#NUMERO: ["0" - "9"]>
    |
    <CADENA_TEXTO: "\"" ( ~["\""] )* "\"">
    |
    <CARACTER_TEXTO: "'"( ~["'"] | "" )"'">
    |
    <NUMERO_ENTERO: ("-" | "" | "+")(<NUMERO>)+>
    |
    <NUMERO_DECIMAL: ("-" | "" | "+")(<NUMERO>)+"."(<NUMERO>)+>
    |
    <BOOLEANO_FALSO: "Falso">
    |
    <BOOLEANO_VERDADERO: "Verdadero">
    |
    <DELIMITADOR: ";">

}

// Escritura, Lectura y Definición de variables
TOKEN : {
    <INTERPRETAR: "Interpretar">
    |
    <ESCRIBIR: "Escribir">
    |
    <ESTABLECER: "Establecer">
}

// Operadores
TOKEN : {
    <ASIGNACION: "=">
    |
    <SUMA: "+">
    |
    <RESTA: "-">
    |
    <MULTIPLICACION: "*">
    |
    <DIVISION: "/">
    |
    <MODULO: "%">
    |
    <LOGICO_AND: "&&">
    |
    <LOGICO_OR: "||">
    |
    <LOGICO_NOT: "!">
    |
    <OPERADOR_IGUAL: "==">
    |
    <OPERADOR_DIFERENTE: "!=">
    |
    <OPERADOR_MAYOR: ">">
    |
    <OPERADOR_MENOR: "<">
    |
    <OPERADOR_MAYOR_IGUAL: ">=">
    |
    <OPERADOR_MENOR_IGUAL: "<=">
    |
    <OPERADOR_DOS_PUNTOS: ":">
    |
    <PAREN_ABIERTO: "(">
    |
    <PAREN_CERRADO: ")">
    |
    // Nuevo
    <INDICE_ABIERTO: "[">
    |
    // Nuevo
    <INDICE_CERRADO: "]">
}

// Ciclos
TOKEN : {
    <INICIO_CICLO_PARA: "Para">
    |
    <CONDICION_CICLO_PARA: "Hasta que">
    |
    <INCREMENTO_CICLO_PARA: "Con incremento">
    |
    <FIN_CICLO_PARA: "FinPara">
    |
    <INICIO_CICLO_MIENTRAS: "Mientras">
    |
    <FIN_CICLO_MIENTRAS: "FinMientras">
    |
    <INICIO_CICLO_REPETIR: "Repetir">
    |
    <CONDICION_CICLO_REPETIR: "Finaliza cuando">
}

// Condicionales
TOKEN : {
    <INICIO_CONDICIONAL_SI:"Si">
    |
    <ENTONCES:"Entonces">
    |
    <CONDICIONAL_SINO:"Sino">
    |
    <FIN_CONDICIONAL_SI:"FinSi">
    |
    <INICIO_CONDICIONAL_CONFORME:"Conforme">
    |
    <CASO:"Caso">
    |
    <CASO_PREDETERMINADO:"En otro caso">
    |
    <FIN_CONFORME:"FinConforme">
    |
    <HACER : "Hacer">
}

//Variables
TOKEN : {
    <VARIABLE:(<LETRA> | "_")(<NUMERO> | <LETRA> | "_")*>
}

SKIP : {
    " "
    | "\t"
    | "\r\n"
    | "\n"
    | <COMENTARIO: "#" (~["\r", "\n"])* ( ( "\r" )? "\n" | "\r")>
    // Tokens invalidos
    | <NUMERO_INVALIDO: ("-" | "" | "+")(<NUMERO>)*("."( <NUMERO> | <LETRA> )* | <LETRA>)+>{

        compilador.tablaErrores.add("Error léxico en línea " +
                         matchedToken.beginLine + ", columna " + matchedToken.beginColumn +
                         ". Se encontró un número inválido '" + matchedToken.image + "'.\n" +
                         "        Posible solución: Remover o revisar número.");

    }
    | <INVALIDO: ~[]>{

        compilador.tablaErrores.add("Error léxico en línea " +
                     matchedToken.beginLine + ", columna " + matchedToken.beginColumn +
                     ". Se encontró símbolo inválido '" + matchedToken.image + "'.\n" +
                     "        Posible solución: Remover símbolo.");

    }

}

// Gramaticas

// Nuevo
void argumentos() : { } {
    ( tiposDato() <VARIABLE> ( <COMA> tiposDato() <VARIABLE> )* )?
}

// Nuevo
void declaracionFuncion() : { }{
    <FUNCION> ( tiposDato() )? <VARIABLE> <PAREN_ABIERTO> argumentos() <PAREN_CERRADO>
    ( sentencias() )*
    <FIN_FUNCION> <VARIABLE>
}

void programa(): { }{

    try {
        // Nuevo
        ( declaracionFuncion() )+
        <EOF>

        // Eliminado
        // <INICIO> ( sentencias() )+ <FIN><EOF>
    } catch (ParseException ex){

        processError(ex, "programa principal");

        skipTo(FIN_FUNCION);
    }
}

void sentencias():{ }{

    sentenciaAsignacion() |
    // Nuevo
    sentenciaDeclaracion() |
    // Eliminado
    // sentenciaDeclaracionVariables() |
    leerDato() |
    imprimirDato() |
    sentenciaSi() |
    sentenciaConforme() |
    sentenciaPara() |
    sentenciaRepetir() |
    sentenciaMientras()

}

void sentenciaAsignacion():{ }{

    try {
        <VARIABLE> asignacion() <DELIMITADOR>
    } catch (ParseException ex) {

        processError(ex, "sentencia de asignacion");

        skipTo(DELIMITADOR, SENTENCES_BEGIN);

    }

}

// Nuevo
void sentenciaDeclaracion() : { }{

    try {
        ( declaracionVariables() | declaracionArreglo() ) <DELIMITADOR>
    } catch (ParseException ex) {

        processError(ex, "sentencia de declaración");

        skipTo(DELIMITADOR, SENTENCES_BEGIN);

    }
}

// Eliminar
void sentenciaDeclaracionVariables():{ }{

    try {
        declaracionVariables() <DELIMITADOR>
    } catch (ParseException ex) {

        processError(ex, "sentencia de declaración de variable");

        skipTo(DELIMITADOR, SENTENCES_BEGIN);

    }

}

void tiposDato():{ }{
    <ENTERO> | <FLOTANTE> | <CADENA> | <CARACTER> | <BOOLEANO>
}

void constantes():{ }{
    <NUMERO_ENTERO> | <NUMERO_DECIMAL> | <CADENA_TEXTO> | <CARACTER_TEXTO> | <BOOLEANO_FALSO> | <BOOLEANO_VERDADERO>
}

// Editado
void asignacion():{ }{
    <ASIGNACION>  expresion()
}

// Nuevo
void expresion(): { }{
    logicoOr()
}

// Nuevo
void logicoOr() : { }{
    logicoAnd() ( <LOGICO_OR> logicoAnd() )*
}

// Nuevo
void logicoAnd() : { }{
    comparacion() ( <LOGICO_AND> comparacion() )*
}

// Nuevo
void comparacion() : { }{
    operando() ( <OPERADOR_IGUAL> operando()
               | <OPERADOR_DIFERENTE> operando()
               | <OPERADOR_MAYOR> operando()
               | <OPERADOR_MENOR> operando()
               | <OPERADOR_MAYOR_IGUAL> operando()
               | <OPERADOR_MENOR_IGUAL> operando() )?
}

// Nuevo
void operando() : { }{
    termino() ( ( <SUMA> | <RESTA> ) termino() )*
}

// Nuevo
void termino(): { }{
    factor() ( ( <MULTIPLICACION> | <DIVISION> | <MODULO> ) factor() )*
}

// Nuevo
void factor() : { }{
    <VARIABLE> |
    constantes() |
    <PAREN_ABIERTO> expresion() <PAREN_CERRADO> |
    <LOGICO_NOT> factor()
}

// Eliminado
void operacionParentesis():{}{
    ""
}

// Eliminado
void operadores():{}{
    operadoresAritmeticos() | operadoresLogicos() | operadoresRelacionales()
}

// Eliminado
void operacion():{} {
    ""
}

// Eliminado
void condicion():{} {
    ""
}

// Eliminado
void operadoresAritmeticos():{ }{
    <SUMA> | <RESTA> | <MULTIPLICACION> | <DIVISION> | <MODULO>
}

// Eliminado
void operadoresRelacionales():{ }{
    <OPERADOR_IGUAL> | <OPERADOR_DIFERENTE> | <OPERADOR_MAYOR> | <OPERADOR_MAYOR_IGUAL> | <OPERADOR_MENOR> | <OPERADOR_MENOR_IGUAL>
}

// Eliminado
void operadoresLogicos():{ }{
    <LOGICO_AND> | <LOGICO_OR>
}

// Nuevo
void declaracionArreglo():{ }{
    <ESTABLECER> tiposDato() <INDICE_ABIERTO> expresion() <INDICE_CERRADO> <VARIABLE>
}

void declaracionVariables():{ }{
    <ESTABLECER> tiposDato() <VARIABLE> ( asignacion() )?
}

void leerDato():{ }{

    try {
        <INTERPRETAR> <VARIABLE> <DELIMITADOR>
    } catch (ParseException ex) {

        processError(ex, "sentencia de lectura de dato");

        skipTo(DELIMITADOR, SENTENCES_BEGIN);

    }
}

void imprimirDato():{}{

    try {
        <ESCRIBIR> ( constantes() | <VARIABLE> ) <DELIMITADOR>
    } catch (ParseException ex) {

        processError(ex, "sentencia de escritura de dato");

        skipTo(DELIMITADOR, SENTENCES_BEGIN);

    }

}

// Editado
void sentenciaSi():{}{

    try {
        <INICIO_CONDICIONAL_SI> expresion() <ENTONCES> ( sentencias() )*
        ( <CONDICIONAL_SINO> ( sentencias() )* )?
        <FIN_CONDICIONAL_SI>
    } catch (ParseException ex) {

        processError(ex, "sentencia condicional Si");

        skipTo(FIN_CONDICIONAL_SI);

    }

}

void sentenciaConforme():{}{

    try {
        <INICIO_CONDICIONAL_CONFORME> <VARIABLE> <HACER>
        ( <CASO> constantes() <OPERADOR_DOS_PUNTOS> ( sentencias() )* )+
        ( <CASO_PREDETERMINADO> <OPERADOR_DOS_PUNTOS> ( sentencias() )* )?
        <FIN_CONFORME>
    } catch (ParseException ex) {

        processError(ex, "sentencia condicional Conforme");

        skipTo(FIN_CONFORME);

    }

}

// Editado
void sentenciaPara():{}{

    try {
        <INICIO_CICLO_PARA> (<VARIABLE> <ASIGNACION> ( constantes() | <VARIABLE> ) | declaracionVariables() )
        <CONDICION_CICLO_PARA> expresion() <INCREMENTO_CICLO_PARA> ( <NUMERO_ENTERO> | <NUMERO_DECIMAL> )
        ( sentencias() )*
        <FIN_CICLO_PARA>
    } catch (ParseException ex) {

        processError(ex, "sentencia de bucle Para");

        skipTo(FIN_CICLO_PARA);

    }


}

// Editado
void sentenciaRepetir():{}{

    try {
        <INICIO_CICLO_REPETIR> ( sentencias() )*
        <CONDICION_CICLO_REPETIR> expresion() <DELIMITADOR>
    } catch (ParseException ex) {

        processError(ex, "sentencia de bucle Repetir");

        skipTo(DELIMITADOR, SENTENCES_BEGIN);

    }

}

// Editado
void sentenciaMientras():{}{

    try {
        <INICIO_CICLO_MIENTRAS> expresion() <HACER>
        ( sentencias() )*
        <FIN_CICLO_MIENTRAS>
    } catch (ParseException ex) {

        processError(ex, "sentencia de bucle Mientras");

        skipTo(FIN_CICLO_MIENTRAS);

    }


}