
options {
    STATIC = false;
}

PARSER_BEGIN(EC)

import java.io.*;
import java.util.*;
import java.util.function.*;
import java.util.stream.Collectors;
import java.util.stream.*;
import java.lang.reflect.*;

public class EC {

    final static int EXP_VARIABLE = 1;
    final static int EXP_ARREGLO = 2;
    final static int EXP_FUNCION = 3;

    final static int TIPO_VACIO = -1;
    final static int TIPO_ENTERO = ECConstants.ENTERO << 1;
    final static int TIPO_FLOTANTE = ECConstants.FLOTANTE << 1;
    final static int TIPO_CADENA = ECConstants.CADENA << 1;
    final static int TIPO_CARACTER = ECConstants.CARACTER << 1;
    final static int TIPO_BOOLEANO = ECConstants.BOOLEANO << 1;

    final Integer[] SENTENCES_BEGIN = new Integer[]
            {VARIABLE, ESTABLECER, INTERPRETAR, ESCRIBIR, INICIO_CONDICIONAL_SI, INICIO_CONDICIONAL_CONFORME,
            INICIO_CICLO_PARA, INICIO_CICLO_REPETIR, INICIO_CICLO_MIENTRAS};

    final ArrayList<String> tablaErrores = new ArrayList<String>();

    final StringBuilder codigoIntermedio = new StringBuilder();

    public class Ambito {

        public final HashMap<String, Expresion> tablaSimbolos;

        public Ambito(){
            tablaSimbolos = new HashMap<String, Expresion>();
        }

        public Ambito(Ambito from){
            this();

            tablaSimbolos.putAll(from.tablaSimbolos);
        }
    }

    public class Tupla<A, B> {
        private final A primero;
        private final B segundo;

        public Tupla(A primero, B segundo) {
            this.primero = primero;
            this.segundo = segundo;
        }

        public A getPrimero() {
            return primero;
        }

        public B getSegundo() {
            return segundo;
        }

        @Override
        public String toString() {
            return "(" + primero + ", " + segundo + ")";
        }
    }

    public class Expresion {

        public String nombre;

        public int tipoDato;

        public int tipoExpresion = EXP_VARIABLE;

        public Token token;

        public ArrayList<Expresion> expresiones = new ArrayList<Expresion>();

        public boolean isError = false;

        public static final Function<Expresion, Integer> mapper = new Function<Expresion, Integer>() {
            @Override
            public Integer apply(Expresion e){
                return e.tipoDato;
            }
        };

        public static final Predicate<Expresion> errorP = new Predicate<Expresion>() {
             @Override
             public boolean test(Expresion e) {
                 return e.isError;
             }
         };

        public boolean tieneErrores() {

            if(isError) return true;

            return expresiones.stream().anyMatch(Expresion.errorP);
        }

        public static String getTipoDatoNombre(int tipoDato){

            switch (tipoDato){

                case TIPO_VACIO:
                    return "Vacio";
                case TIPO_ENTERO:
                    return "Entero";
                case TIPO_FLOTANTE:
                    return "Flotante";
                case TIPO_CADENA:
                    return "Cadena";
                case TIPO_CARACTER:
                    return "Caracter";
                case TIPO_BOOLEANO:
                    return "Booleano";

                case TIPO_ENTERO | 1:
                    return "Entero[]";
                case TIPO_FLOTANTE | 1:
                    return "Flotante[]";
                case TIPO_CADENA | 1:
                    return "Cadena[]";
                case TIPO_CARACTER | 1:
                    return "Caracter[]";
                case TIPO_BOOLEANO | 1:
                    return "Booleano[]";

            }

            return "Indefinido";
        }

        public static boolean isArreglo(int tipoDato) {
            return (tipoDato & 1) != 0;
        }

        public static boolean puedeOperar(int tipoDato, int operador){

            boolean eq = false;

            switch(operador){
                case ECConstants.SUMA:
                    return tipoDato == TIPO_ENTERO || tipoDato == TIPO_FLOTANTE
                    || tipoDato == TIPO_CADENA || tipoDato == TIPO_CARACTER;
                case ECConstants.RESTA:
                case ECConstants.MULTIPLICACION:
                case ECConstants.DIVISION:
                case ECConstants.MODULO:
                    return tipoDato == TIPO_ENTERO || tipoDato == TIPO_FLOTANTE;

                case ECConstants.LOGICO_NOT:
                case ECConstants.LOGICO_OR:
                case ECConstants.LOGICO_AND:
                    return tipoDato == TIPO_BOOLEANO;

                case ECConstants.OPERADOR_IGUAL:
                case ECConstants.OPERADOR_DIFERENTE:
                    eq = tipoDato == TIPO_CADENA || tipoDato == TIPO_BOOLEANO;
                case ECConstants.OPERADOR_MAYOR:
                case ECConstants.OPERADOR_MAYOR_IGUAL:
                case ECConstants.OPERADOR_MENOR:
                case ECConstants.OPERADOR_MENOR_IGUAL:
                    return eq || tipoDato == TIPO_ENTERO || tipoDato == TIPO_FLOTANTE
                        || tipoDato == TIPO_CARACTER;
            }

            return false;

        }
    }

    public static class Reporte {

        public boolean isError = false;

        public List<String> lineas = new ArrayList<String>();

    }

    private static final Function<String, String> formaLista = new Function<String, String>() {
        @Override
        public String apply(String s){
            return "- " + s;
        }
    };

    private static final Function<String, String> tabMapper = new Function<String, String>() {
        @Override
        public String apply(String s){
            return s.replace("\t", "    ");
        }
    };

    private static final Function<String, Stream<String>> flatMapper = new Function<String, Stream<String>>() {
        @Override
        public Stream<String> apply(String s){
            return Stream.of(s.split("\n"));
        }
    };

    private static final ToIntFunction<String> intMapper = new ToIntFunction<String>() {
        @Override
        public int applyAsInt(String s){
            return s.length();
        }
    };

    private static final Predicate<Field> fieldFilter = new Predicate<Field>() {
        @Override
        public boolean test(Field f){
            return f.getType() == int.class;
        }
    };

    private static final BinaryOperator<String> fieldMarge = new BinaryOperator<String>() {
        @Override
        public String apply(String x, String y){
            return x;
        }
    };

    private static final Function<Field, Integer> keyMapper = new Function<Field, Integer>() {
        @Override
        public Integer apply(Field f) {
            try{
                return f.getInt(null);
            } catch (IllegalAccessException ex) {
                return 0;
            }

        }
    };

    private static final Function<Field, String> valueMapper = new Function<Field, String>() {
        @Override
        public String apply(Field f){
            return f.getName();
        }
    };

    private static final Map<Integer, String> tiposTokens
    = Arrays.stream(ECConstants.class.getDeclaredFields())
                                  .filter(fieldFilter)
                                  .collect(Collectors.toMap(keyMapper, valueMapper, fieldMarge));

    public static Reporte lexica(String archivo) {
        Reporte reporte = new Reporte();

        if (archivo.isBlank()) {
            reporte.lineas.add("ERROR: Debe de ingresar el archivo del código fuente.");
            reporte.isError = true;
            return reporte;
        }

        try {

            FileReader sourceFileReader = new FileReader(archivo);

            EC ec = new EC(sourceFileReader);

            reporte.lineas.add("Fase léxica: Tipo -> Valor.");

            for(Token token = ec.getNextToken(); token.kind != ECConstants.EOF; token = ec.getNextToken()) {

                String tipo = tiposTokens.get(token.kind);
                reporte.lineas.add(String.format("\t<%s> -> %s", tipo, token.image));

            }

            var errores = ec.tablaErrores;

            if (!errores.isEmpty()){

                reporte.isError = true;
                reporte.lineas.clear();
                String str1 = "encontraron";
                String str2 = "errores";
                int cErrores = errores.size();

                if (cErrores == 1) {
                    str1 = "encontró";
                    str2 = "error";
                }

                reporte.lineas.add(String.format("Se %s %d %s durante la prueba léxica:", str1, cErrores, str2));
                reporte.lineas.add(" ");

                var errors = errores.stream()
                                  .map(formaLista)
                                  .flatMap(flatMapper)
                                  .map(tabMapper)
                                  .toList();

                reporte.lineas.addAll(errors);

            }else{
                reporte.lineas.add("Se pasó la prueba léxica con éxito.");
                reporte.lineas.add("No se encontraron errores.");
            }

            return reporte;

        } catch (FileNotFoundException ex) {
            reporte.lineas.add("ERROR: No se encontró el archivo.");
            reporte.isError = true;
        }

        return reporte;
    }

    public static Reporte semantica(String archivo) {

        Reporte reporte = new Reporte();

        if (archivo.isBlank()) {
            reporte.lineas.add("ERROR: Debe de ingresar el archivo del código fuente.");
            reporte.isError = true;
            return reporte;
        }

        try {

            FileReader sourceFileReader = new FileReader(archivo);

            EC ec = new EC(sourceFileReader);

            ec.programa();

            var errores = ec.tablaErrores;

            reporte.lineas.add("Se pasó la prueba semántica con éxito.");
            reporte.lineas.add("No se encontraron errores.");

            if (!errores.isEmpty()){

                reporte.isError = true;
                reporte.lineas.clear();
                String str1 = "encontraron";
                String str2 = "errores";
                int cErrores = errores.size();

                if (cErrores == 1) {
                    str1 = "encontró";
                    str2 = "error";
                }

                reporte.lineas.add(String.format("Se %s %d %s durante la prueba semántica:", str1, cErrores, str2));
                reporte.lineas.add(" ");

                var errors = errores.stream()
                                  .map(formaLista)
                                  .flatMap(flatMapper)
                                  .toList();

                reporte.lineas.addAll(errors);
            }

            return reporte;

        } catch (FileNotFoundException ex) {
            reporte.lineas.add("ERROR: No se encontró el archivo.");
            reporte.isError = true;
        } catch (ParseException ex) {
            reporte.lineas.clear();
            reporte.lineas.add("Ha ocurrido un error inesperado, intente de nuevo.");
            reporte.isError = true;
        }

        return reporte;

    }

    public static void main(String[] args) {

        String archivo = "";
        String fase = "sem";

        if (args.length != 0) {
            archivo = args[0];
        }

        if (archivo.startsWith("-")) {
            fase = archivo.substring(1);

            if (args.length > 1) {
                archivo = args[1];
            }else{
                archivo = "";
            }

        }

        Reporte reporte = null;

        switch (fase) {
            case "l": // Fase léxica
                reporte = lexica(archivo);
                break;
            case "sem": // Fase semántica
                reporte = semantica(archivo);
                break;
            default: // Fase no definida
                reporte = new Reporte();
                reporte.isError = true;
                reporte.lineas.add("ERROR: Esta fase todavía no está implementada.");
                break;
        }

        reporte.lineas = reporte.lineas.stream()
                                .map(tabMapper)
                                .toList();

        int maxLength = reporte.lineas
                               .stream()
                               .mapToInt(intMapper)
                               .max()
                               .orElse(0);

        // Top border
        System.out.print("╔");
        for (int i = 0; i < maxLength + 2; i++) {
            System.out.print("═");
        }
        System.out.println("╗");

        // Content with side borders
        for (String linea : reporte.lineas) {
            System.out.printf("║ %-" + maxLength + "s ║\n", linea);
        }

        // Bottom border
        System.out.print("╚");
        for (int i = 0; i < maxLength + 2; i++) {
            System.out.print("═");
        }
        System.out.println("╝");

        System.exit(reporte.isError ? -1 : 0);

    }

    public EC(FileReader fileReader) {
        this((Reader)fileReader);

        token_source.compilador = this;

    }

    private void processError(ParseException ex, String from){

        // Tokens esperados
        StringBuilder expected = new StringBuilder();

        int maxSize = 0;

        for (int i = 0; i < ex.expectedTokenSequences.length; i++) {
            if (maxSize < ex.expectedTokenSequences[i].length) {
                maxSize = ex.expectedTokenSequences[i].length;
            }
            for (int j = 0; j < ex.expectedTokenSequences[i].length; j++) {
                expected.append(tokenImage[ex.expectedTokenSequences[i][j]]).append(' ');
            }

        }

        Token tokenError = ex.currentToken.next;

        // Tokens encontrados
        ArrayList<Token> tokens = new ArrayList<Token>();
        tokens.add(tokenError);

        for (Token t = tokenError; t.next != null; t = t.next) {

            tokens.add(t);
        }

        String[] expecteds = expected.toString().split(" ");

        StringBuilder msg = new StringBuilder();
        msg.append("Error sintáctico en ").append(from).append(',')
        .append(" linea ").append(tokenError.endLine).append(", columna ").append(tokenError.endColumn).append('.');

        if (tokens.size() == 1) {

            if(token.kind == ECConstants.CADENA_TEXTO){
                msg.append(String.format("\n\tSe encontró el símbolo %s.", tokenImage[token.kind]));
            } else {
                msg.append(String.format("\n\tSe encontró el símbolo \"%s\".", token.image));

                if(!tokenImage[tokenError.kind].regionMatches(1, tokenError.image,0,tokenError.image.length()))
                    msg.append(" (").append(tokenImage[tokenError.kind]).append(')').append('.');
            }

        } else {
            msg.append("\n\tSe encontraron los símbolos:");
            for (Token token : tokens) {

                if(token.kind == ECConstants.CADENA_TEXTO){
                    msg.append(String.format("\n\t\t - %s.", tokenImage[token.kind]));
                } else {
                    msg.append(String.format("\n\t\t - \"%s\".", token.image));

                    if(!tokenImage[token.kind].regionMatches(1, token.image,0,token.image.length()))
                        msg.append(" (").append(tokenImage[token.kind]).append(')').append('.');
                }

            }
        }

        if (expecteds.length == 1){
            msg.append("\n\tSe esperaba ").append(expecteds[0]).append('.');
        } else {
            msg.append("\n\tSe esperaba uno de los siguientes: ");
            for (String e : expecteds) {
                msg.append("\n\t - ").append(e);
            }
        }

        tablaErrores.add(msg.toString());
    }

    private void skipTo(Integer end, Integer... kinds) {

        List<Integer> kindsList = Arrays.asList(kinds);

        HashSet<Integer> cKinds = new HashSet<Integer>(kindsList);
        cKinds.add(end);
        cKinds.add(FIN_FUNCION);
        cKinds.add(FIN);
        cKinds.add(EOF);

        Token oldToken = token;
        boolean sw = true;
        int selectedKind = EC.EOF;

        do {
            token = getNextToken();

            for (Integer kind : cKinds) {
                sw &= token.kind != kind;

                if (!sw) {
                    selectedKind = kind;
                    break;
                }
            }

        } while (sw);

        if (selectedKind != end) {
            token = oldToken;
            jj_kind = selectedKind;
        }

    }

}

PARSER_END(EC)

TOKEN_MGR_DECLS:{
    EC compilador;
}
// Inicio y fin del programa
TOKEN : {

    <INICIO: "Inicio">
    |
    <FIN: "Fin">

}

// Funciones
TOKEN : {

    <COMA: ",">
    |
    <FUNCION: "Funcion" >
    |
    <FIN_FUNCION: "FinFuncion">
    |
    <RETORNAR: "Retornar">
}

// Tipos de dato
TOKEN : {

    <ENTERO: ("Entero" | "entero")>
    |
    <FLOTANTE: ("Flotante" | "flotante")>
    |
    <CADENA: ("Cadena" | "cadena")>
    |
    <CARACTER: ("Caracter" | "caracter")>
    |
    <BOOLEANO: ("Booleano" | "booleano")>
}

// Escritura, Lectura y Definición de variables
TOKEN : {
    <INTERPRETAR: "Interpretar">
    |
    <ESCRIBIR: "Escribir">
    |
    <ESTABLECER: "Establecer">
}

// Operadores
TOKEN : {
    <ASIGNACION: "=">
    |
    <SUMA: "+">
    |
    <RESTA: "-">
    |
    <MULTIPLICACION: "*">
    |
    <DIVISION: "/">
    |
    <MODULO: "%">
    |
    <LOGICO_AND: "&&">
    |
    <LOGICO_OR: "||">
    |
    <LOGICO_NOT: "!">
    |
    <OPERADOR_IGUAL: "==">
    |
    <OPERADOR_DIFERENTE: "!=">
    |
    <OPERADOR_MAYOR: ">">
    |
    <OPERADOR_MENOR: "<">
    |
    <OPERADOR_MAYOR_IGUAL: ">=">
    |
    <OPERADOR_MENOR_IGUAL: "<=">
    |
    <OPERADOR_DOS_PUNTOS: ":">
    |
    <PAREN_ABIERTO: "(">
    |
    <PAREN_CERRADO: ")">
    |
    <INDICE_ABIERTO: "[">
    |
    <INDICE_CERRADO: "]">
}

// Constantes/Literales
TOKEN : {
    <#LETRA: ["a" - "z", "ñ"] | ["A" - "Z", "Ñ"]>
    |
    <#NUMERO: ["0" - "9"]>
    |
    <CADENA_TEXTO: "\"" ( ~["\""] )* "\"">
    |
    <CARACTER_TEXTO: "'"( ~["'"] | "" )"'">
    |
    <NUMERO_ENTERO: (<NUMERO>)+>
    |
    <NUMERO_DECIMAL: (<NUMERO>)+"."(<NUMERO>)+>
    |
    <BOOLEANO_FALSO: "Falso">
    |
    <BOOLEANO_VERDADERO: "Verdadero">
    |
    <DELIMITADOR: ";">

}

// Ciclos
TOKEN : {
    <INICIO_CICLO_PARA: "Para">
    |
    <CONDICION_CICLO_PARA: "Hasta que">
    |
    <INCREMENTO_CICLO_PARA: "Con incremento">
    |
    <FIN_CICLO_PARA: "FinPara">
    |
    <INICIO_CICLO_MIENTRAS: "Mientras">
    |
    <FIN_CICLO_MIENTRAS: "FinMientras">
    |
    <INICIO_CICLO_REPETIR: "Repetir">
    |
    <CONDICION_CICLO_REPETIR: "Finaliza cuando">
}

// Condicionales
TOKEN : {
    <INICIO_CONDICIONAL_SI:"Si">
    |
    <ENTONCES:"Entonces">
    |
    <CONDICIONAL_SINO:"Sino">
    |
    <FIN_CONDICIONAL_SI:"FinSi">
    |
    <INICIO_CONDICIONAL_CONFORME:"Conforme">
    |
    <CASO:"Caso">
    |
    <CASO_PREDETERMINADO:"En otro caso">
    |
    <FIN_CONFORME:"FinConforme">
    |
    <HACER : "Hacer">
}

//Variables
TOKEN : {
    <VARIABLE:(<LETRA> | "_")(<NUMERO> | <LETRA> | "_")*>
}

SKIP : {
    " "
    | "\t"
    | "\r\n"
    | "\n"
    | <COMENTARIO: "#" (~["\r", "\n"])* ( ( "\r" )? "\n" | "\r")>

}

// Tokens invalidos
TOKEN : {

    <NUMERO_INVALIDO: (<NUMERO>)*("."( <NUMERO> | <LETRA> )* | <LETRA>)+>{

        compilador.tablaErrores.add("Error léxico, línea "
                        + matchedToken.beginLine + ", columna " + matchedToken.beginColumn
                        + ".\n\tSe encontró un número inválido '" + matchedToken.image + "'."
                        + "\n\tPosible solución: Remover o revisar número.");

    }
    | <INVALIDO: ~[]>{

        compilador.tablaErrores.add("Error léxico, línea " +
                     matchedToken.beginLine + ", columna " + matchedToken.beginColumn +
                     ".\nSe encontró símbolo inválido '" + matchedToken.image + "'." +
                     "\n\tPosible solución: Remover símbolo.");

    }

}

// Gramaticas

ArrayList<Integer> argumentos(Ambito ambito) :
{
    int tipoDato;
    ArrayList<Integer> argumentos = new ArrayList<Integer>();
}
{
    tipoDato = expresion(ambito)
    {
        argumentos.add(tipoDato);
    }
    (
        <COMA>
        tipoDato = expresion(ambito)
        {
            argumentos.add(tipoDato);
        }
    )*
    {
        return argumentos;
    }
}

ArrayList<Expresion> declaracionArgumentos(Ambito ambito) :
{
    Expresion argumento = new Expresion();
    ArrayList<Expresion> argumentos = new ArrayList<Expresion>();
} {
    argumento.tipoDato = tiposDato()
    <VARIABLE>
    {

        if(ambito.tablaSimbolos.containsKey(token.image)){

            tablaErrores.add("Error semántico, Línea " + token.beginLine + ", columna " + token.beginColumn
                           + ".\n\tEl símbolo \"" + token.image + "\" ya está declarado en este ámbito." +
                             "\n\tQuitar declaración doble.");

            argumento.isError = true;
        }

        argumento.token = token;
        argumento.nombre = token.image;

        if(!argumento.tieneErrores()){
            ambito.tablaSimbolos.put(argumento.nombre, argumento);
        }

        argumentos.add(argumento);

    }
    (
        <COMA>
        {
            argumento = new Expresion();
        }
        argumento.tipoDato = tiposDato()
        <VARIABLE>
        {

            if(ambito.tablaSimbolos.containsKey(token.image)){

                tablaErrores.add("Error semántico, Línea " + token.beginLine + ", columna " + token.beginColumn
                               + ".\n\tEl símbolo \"" + token.image + "\" ya está declarado en este ámbito." +
                                 "\n\tQuitar declaración doble.");

                argumento.isError = true;
            }

            argumento.token = token;
            argumento.nombre = token.image;

            if(!argumento.tieneErrores()){
                ambito.tablaSimbolos.put(argumento.nombre, argumento);
            }

            argumentos.add(argumento);
        }
    )*
    {
        return argumentos;
    }
}

void declaracionFuncion(Ambito ambito) :
{
    int tipoDato;
    Expresion funcion = new Expresion();
    funcion.tipoExpresion = EXP_FUNCION;
    funcion.tipoDato = TIPO_VACIO;

    Ambito ambitoFuncion = new Ambito();
}{
    <FUNCION> ( funcion.tipoDato = tiposDato() )?
    <VARIABLE>
    {

        if (ambito.tablaSimbolos.containsKey(token.image)) {

            tablaErrores.add("Error semántico, Línea " + token.beginLine + ", columna " + token.beginColumn
                           + ".\n\tEl símbolo \"" + token.image + "\" ya está declarado en este ámbito." +
                             "\n\tQuitar declaración doble.");

            funcion.isError = true;
        }

        funcion.nombre = token.image;
        funcion.token = token;
        ambitoFuncion.tablaSimbolos.put(funcion.nombre, funcion);

        if (!funcion.tieneErrores()) {
            ambito.tablaSimbolos.put(funcion.nombre, funcion);
        }

    }
     <PAREN_ABIERTO> ( funcion.expresiones = declaracionArgumentos(ambitoFuncion) )? <PAREN_CERRADO>
    ( sentencias(ambitoFuncion) )*
    (
        <RETORNAR>
        tipoDato = expresion(ambitoFuncion)
        <DELIMITADOR>
        {

            if (!funcion.tieneErrores() && funcion.tipoDato == TIPO_VACIO) {

                tablaErrores.add("Error semántico, Línea " + token.beginLine + ", columna " + token.beginColumn
                               + ".\n\tLa función \"" + funcion.nombre + "\" no puede retornar ningun valor."
                               + "\n\tQuitar retornar.");

                funcion.isError = true;

            }

            if (!funcion.tieneErrores() && funcion.tipoDato != tipoDato) {

                tablaErrores.add("Error semántico, Línea " + token.beginLine + ", columna " + token.beginColumn
                               + ".\n\tLa función \"" + funcion.nombre + "\" no puede retornar un tipo de dato \""
                               +  Expresion.getTipoDatoNombre(tipoDato) + "\"."
                               + "\n\tRetornar tipo de dato \"" + Expresion.getTipoDatoNombre(funcion.tipoDato) + "\"." );

                funcion.isError = true;

            }

        }
    )?
    <FIN_FUNCION> <VARIABLE>
    {
        if(!funcion.nombre.equals(token.image)){

            tablaErrores.add("Error semántico, Línea " + token.beginLine + ", columna " + token.beginColumn
                           + ".\n\tLa función debe de terminar con el mismo nombre."
                           + "\n\tColocar el nombre de la función después del FinFuncion.");

            if (!funcion.tieneErrores()) {
                ambito.tablaSimbolos.remove(funcion.nombre);
            }

            funcion.isError = true;


        }
    }
}

void programa():
{
    Ambito ambitoPrincipal = new Ambito();
}{

    try {
        // Nuevo
        ( declaracionFuncion(ambitoPrincipal) )*
        <INICIO> ( sentencias(ambitoPrincipal) )+ <FIN>
        <EOF>

        // Eliminado
        // <INICIO> ( sentencias() )+ <FIN><EOF>
    } catch (ParseException ex){

        processError(ex, "programa principal");

        skipTo(FIN_FUNCION);
    }
}

void sentencias(Ambito ambito):{ }{

    sentenciaDeclaracion(ambito) |
    sentenciaAsignacion(ambito) |
    leerDato(ambito) |
    imprimirDato(ambito) |
    sentenciaSi(ambito) |
    sentenciaConforme(ambito) |
    sentenciaPara(ambito) |
    sentenciaRepetir(ambito) |
    sentenciaMientras(ambito)

}

void sentenciaAsignacion(Ambito ambito) :
{
    Tupla<Integer, Token> tupla;
} {

    try {
        tupla = llamadas(ambito)
        ( asignacion(ambito, tupla) )?
        <DELIMITADOR>
    } catch (ParseException ex) {

        processError(ex, "sentencia de asignacion");

        skipTo(DELIMITADOR, SENTENCES_BEGIN);

    }

}

void sentenciaDeclaracion(Ambito ambito) : { } {

    try {
        declaracion(ambito) <DELIMITADOR>
    } catch (ParseException ex) {

        processError(ex, "sentencia de declaración");

        skipTo(DELIMITADOR, SENTENCES_BEGIN);

    }
}

int tiposDato() : { } {
    ( <ENTERO>
    |
    <FLOTANTE>
    |
    <CADENA>
    |
    <CARACTER>
    |
    <BOOLEANO> ) { return token.kind << 1; }
}

int constantes(): { }{

    <NUMERO_ENTERO> { return TIPO_ENTERO; } // 2
    |
    <NUMERO_DECIMAL> { return TIPO_FLOTANTE; } // 2.3 0.0
    |
    <CADENA_TEXTO> { return TIPO_CADENA; } // "Hola"
    |
    <CARACTER_TEXTO> { return TIPO_CARACTER; } // 'c'
    |
    <BOOLEANO_FALSO> { return TIPO_BOOLEANO; }
    |
    <BOOLEANO_VERDADERO> { return TIPO_BOOLEANO; }
}

void asignacion(Ambito ambito, Tupla<Integer, Token> t):
{
    boolean error = t == null;
    Token tk = t.getSegundo();
    if (!error && !ambito.tablaSimbolos.containsKey(tk.image)) {

        tablaErrores.add("Error semántico, Línea " + tk.beginLine + ", columna " + tk.beginColumn
                        + ".\n\tEl símbolo \"" + tk.image + "\" no está declarado en este ámbito." +
                         "\n\tDeclarar el símbolo.");

        error = true;
    }

    Expresion exp = ambito.tablaSimbolos.get(tk.image);

    if(!error && !exp.tieneErrores() && exp.tipoExpresion == EXP_FUNCION) {

        tablaErrores.add("Error semántico, Línea " + tk.beginLine + ", columna " + tk.beginColumn
                        + ".\n\t\""+ exp.nombre +"\" no es un símbolo asignable." +
                          "\n\tNo se le puede asignar un valor a una llamada de función.");

        error = true;
    }

    int tipoDato;
} {
    <ASIGNACION> tipoDato = expresion(ambito)
    {
        if(tipoDato == 0) {
            error = true;
        }

        int expTipoDato = t.getPrimero();
        if(expTipoDato == -2){
            expTipoDato = exp.tipoDato;
        }

        if(!error && !exp.tieneErrores() && expTipoDato != tipoDato){
            Token token = exp.token;
            tablaErrores.add("Error semántico, Línea " + token.beginLine + ", columna " + token.beginColumn
                           + ".\n\tNo se puede asignar un tipo de dato \"" + Expresion.getTipoDatoNombre(tipoDato)
                           + "\" a un tipo de dato \"" +  Expresion.getTipoDatoNombre(exp.tipoDato) + "\"."
                           + "\n\tSe esperaba tipo de dato \"" +  Expresion.getTipoDatoNombre(exp.tipoDato) + "\".");

        }

    }
}

int expresion(Ambito ambito):
{
    int tipoDato;
}
{
    tipoDato = logicoOr(ambito) { return tipoDato; }
}

int logicoOr(Ambito ambito) :
{
    int tipoIzq;
    int tipoDer;
    Token op;
    boolean error = false;
    boolean sw = false;
}{
    tipoIzq = logicoAnd(ambito)
    {
        if(tipoIzq == 0) error = true;

    }
    ( <LOGICO_OR> { op = token; }
        tipoDer = logicoAnd(ambito)
        {

            if (!error &&
                (tipoIzq != tipoDer || !Expresion.puedeOperar(tipoIzq, op.kind)
                || !Expresion.puedeOperar(tipoDer, op.kind))) {

                tablaErrores.add("Error semántico, Línea " + op.beginLine + ", columna " + op.beginColumn
                                + ".\n\tNo se puede aplicar el operador '" + op.image +  "' entre tipos de dato \"" +
                                 Expresion.getTipoDatoNombre(tipoIzq) + "\" y \"" + Expresion.getTipoDatoNombre(tipoDer) + "\".");

                error = true;

            }

            sw = true;

        }
    )* { return error ? 0 : sw ? TIPO_BOOLEANO : tipoIzq; }
}

int logicoAnd(Ambito ambito) :
{
    int tipoIzq;
    int tipoDer;
    Token op;
    boolean error = false;
    boolean sw = false;
}{
    tipoIzq = comparacion(ambito)
    {
        if(tipoIzq == 0) error = true;
    }
    ( <LOGICO_AND> { op = token; }
        tipoDer = comparacion(ambito)
        {

            if (!error &&
                (tipoIzq != tipoDer || !Expresion.puedeOperar(tipoIzq, op.kind)
                || !Expresion.puedeOperar(tipoDer, op.kind))) {

                tablaErrores.add("Error semántico, Línea " + op.beginLine + ", columna " + op.beginColumn
                                + ".\n\tNo se puede aplicar el operador '" + op.image +  "' entre tipos de dato \"" +
                                 Expresion.getTipoDatoNombre(tipoIzq) + "\" y \"" + Expresion.getTipoDatoNombre(tipoDer) + "\".");

                error = true;

            }

            sw = true;

       }
    )* { return error ? 0 : sw ? TIPO_BOOLEANO : tipoIzq; }
}

int comparacion(Ambito ambito) :
{
    int tipoIzq;
    int tipoDer;
    Token op;
    boolean error = false;
    boolean sw = false;
}
{
    tipoIzq = operando(ambito)
    {
        if(tipoIzq == 0) error = true;

    }
    ( ( <OPERADOR_IGUAL> | <OPERADOR_DIFERENTE> | <OPERADOR_MAYOR_IGUAL> | <OPERADOR_MENOR_IGUAL> | <OPERADOR_MAYOR> | <OPERADOR_MENOR> ) { op = token; }
        tipoDer = operando(ambito)
        {

            if (!error &&
                (tipoIzq != tipoDer || !Expresion.puedeOperar(tipoIzq, op.kind)
                || !Expresion.puedeOperar(tipoDer, op.kind))) {

                tablaErrores.add("Error semántico, Línea " + op.beginLine + ", columna " + op.beginColumn
                                + ".\n\tNo se puede aplicar el operador '" + op.image +  "' entre tipos de dato \"" +
                                 Expresion.getTipoDatoNombre(tipoIzq) + "\" y \"" + Expresion.getTipoDatoNombre(tipoDer) + "\".");

                error = true;

            }

            sw = true;

       }
    )? { return error ? 0 : sw ? TIPO_BOOLEANO : tipoIzq; }
}

int operando(Ambito ambito) :
{
    int tipoIzq;
    int tipoDer;
    Token op;
    boolean error = false;
}{
    tipoIzq = termino(ambito)
    {
        if(tipoIzq == 0) error = true;

    }
    ( ( <RESTA> | <SUMA> ) { op = token; }
        tipoDer = termino(ambito)
        {

            if (!error &&
                (tipoIzq != tipoDer || !Expresion.puedeOperar(tipoIzq, op.kind)
                || !Expresion.puedeOperar(tipoDer, op.kind))) {

                tablaErrores.add("Error semántico, Línea " + op.beginLine + ", columna " + op.beginColumn
                                + ".\n\tNo se puede aplicar el operador '" + op.image +  "' entre tipos de dato \"" +
                                 Expresion.getTipoDatoNombre(tipoIzq) + "\" y \"" + Expresion.getTipoDatoNombre(tipoDer) + "\".");

                error = true;

            }

       }
    )* { return error ? 0 : tipoIzq; }
}

int termino(Ambito ambito):
{
    int tipoIzq;
    int tipoDer;
    Token op;
    boolean error = false;
}{
    tipoIzq = factor(ambito)
    {
        if(tipoIzq == 0) error = true;

    }
    ( ( <MULTIPLICACION> | <DIVISION> | <MODULO> ) { op = token; }
       tipoDer = factor(ambito)
       {

            if (!error &&
                (tipoIzq != tipoDer || !Expresion.puedeOperar(tipoIzq, op.kind)
                || !Expresion.puedeOperar(tipoDer, op.kind))) {

                tablaErrores.add("Error semántico, Línea " + op.beginLine + ", columna " + op.beginColumn
                                + ".\n\tNo se puede aplicar el operador '" + op.image +  "' entre tipos de dato \"" +
                                 Expresion.getTipoDatoNombre(tipoIzq) + "\" y \"" + Expresion.getTipoDatoNombre(tipoDer) + "\".");

                error = true;

            }

       }
    )* { return error ? 0 : tipoIzq; }
}

int factor(Ambito ambito) :
{
    int tipoDato;
    Expresion exp = null;
    Token op;
    boolean error = false;
    Tupla<Integer, Token> tupla;
} {

    tupla = llamadas(ambito) { return tupla.getPrimero(); }
    |
    tipoDato = constantes() { return tipoDato; }
    |
    <PAREN_ABIERTO> tipoDato = expresion(ambito) <PAREN_CERRADO> { return tipoDato; }
    |
    <LOGICO_NOT> { op = token; } tipoDato = factor(ambito)
    {
        if (!Expresion.puedeOperar(tipoDato, op.kind)){

            tablaErrores.add("Error semántico, Línea " + op.beginLine + ", columna " + op.beginColumn
                            + ".\n\tNo se puede aplicar el operador '" + op.image +  "' en tipo de dato \"" +
                             Expresion.getTipoDatoNombre(tipoDato) + "\".");

            return 0;
        }

        return TIPO_BOOLEANO;
    }
    |
    (<SUMA> | <RESTA> ) { op = token; } tipoDato = factor(ambito)
    {
        if (!Expresion.puedeOperar(tipoDato, op.kind)){

            tablaErrores.add("Error semántico, Línea " + op.beginLine + ", columna " + op.beginColumn
                        + ".\n\tNo se puede aplicar el operador '" + op.image +  "' en tipo de dato \"" +
                         Expresion.getTipoDatoNombre(tipoDato) + "\".");

            return 0;
        }

        return tipoDato;
    }

}

Tupla<Integer, Token> llamadas(Ambito ambito) :
{
    Expresion exp = null;
    boolean error = false;
} {
    <VARIABLE>
    {

        if (!ambito.tablaSimbolos.containsKey(token.image)) {

            tablaErrores.add("Error semántico, Línea " + token.beginLine + ", columna " + token.beginColumn
                            + ".\n\tEl símbolo \"" + token.image + "\" no está declarado en este ámbito." +
                             "\n\tDeclarar el símbolo.");
            error = true;
        }

        if (!error) {
            exp = ambito.tablaSimbolos.get(token.image);
        }


    }
    (
        indiceArreglo(ambito)
        {
            if (!error && exp.tieneErrores() && exp.tipoExpresion != EXP_ARREGLO) {

                tablaErrores.add("Error semántico, Línea " + exp.token.beginLine + ", columna " + exp.token.beginColumn
                               + ".\n\tEl símbolo \"" + exp.token.image + "\" no es un arreglo.");

                error = true;
            }

            Tupla<Integer, Token> resultado = new Tupla<Integer, Token>(error ? 0 : (exp.tipoDato >> 1) << 1, exp.token);

            return resultado;
        }
        |
        {
            ArrayList<Integer> args = new ArrayList<Integer>();
        }
        <PAREN_ABIERTO> ( args = argumentos(ambito) )? <PAREN_CERRADO>
        {
            if (!error && exp.tipoExpresion != EXP_FUNCION) {

                tablaErrores.add("Error semántico, Línea " + exp.token.beginLine + ", columna " + exp.token.beginColumn
                               + ".\n\tEl símbolo \"" + exp.token.image + "\" no es una función.");

                error = true;
            }

            List<Integer> tipoArgumentos = exp.expresiones
                                              .stream()
                                              .map(Expresion.mapper)
                                              .toList();

            if(!args.equals(tipoArgumentos)){

                tablaErrores.add("Error semántico, Línea " + exp.token.beginLine + ", columna " + exp.token.beginColumn
                               + ".\n\tLos argumentos proporcionados no coinciden con los de la función.");

                error = true;

            }


        }
    )?
    {
        Tupla<Integer, Token> resultado = new Tupla<Integer, Token>(error ? 0 : exp.tipoDato, error ? null : exp.token);

        return resultado;
    }
}

void indiceArreglo(Ambito ambito) :
{
    int tipoDato;
}{
    (
        <INDICE_ABIERTO>
        tipoDato = expresion(ambito)
        <INDICE_CERRADO>
        {
            if(tipoDato != TIPO_ENTERO){

                tablaErrores.add("Error semántico, Línea " + token.beginLine + ", columna " + token.beginColumn
                                + ".\n\tEl tamaño o el indice de un arreglo debe ser un entero.");

            }

        }
    )+
}

void declaracion(Ambito ambito)
: {

    Expresion declaracion = new Expresion();

} {
    <ESTABLECER> declaracion.tipoDato = tiposDato()
    (
        indiceArreglo(ambito)
        {
            declaracion.tipoDato |= 1;
            declaracion.tipoExpresion = EXP_ARREGLO;
        }
    )?
    <VARIABLE>
    {

        if (ambito.tablaSimbolos.containsKey(token.image)){

            tablaErrores.add("Error semántico, Línea " + token.beginLine + ", columna " + token.beginColumn
                            + ".\n\tEl símbolo \"" + token.image + "\" ya está declarado en este ámbito." +
                             "\n\tQuitar declaración doble.");

            declaracion.isError = true;
        }

        declaracion.token = token;
        declaracion.nombre = token.image;

        if(!declaracion.tieneErrores()) {
            ambito.tablaSimbolos.put(declaracion.nombre, declaracion);
        }

    }
    ( asignacion(ambito, new Tupla<Integer, Token>(-2, declaracion.token) ) )?

}

void leerDato(Ambito ambito) : { } {

    try {
        <INTERPRETAR>
        <VARIABLE>
        {
            if (!ambito.tablaSimbolos.containsKey(token.image)){

                tablaErrores.add("Error semántico, Línea " + token.beginLine + ", columna " + token.beginColumn
                               + ".\n\tEl símbolo \"" + token.image + "\" no está declarado en este ámbito."
                               + "\n\tDeclare una variable para asignarle un valor.");

            }
        }
         <DELIMITADOR>
    } catch (ParseException ex) {

        processError(ex, "sentencia de lectura de dato");

        skipTo(DELIMITADOR, SENTENCES_BEGIN);

    }
}

void imprimirDato(Ambito ambito):{}{

    try {
        <ESCRIBIR> expresion(ambito) <DELIMITADOR>
    } catch (ParseException ex) {

        processError(ex, "sentencia de escritura de dato");

        skipTo(DELIMITADOR, SENTENCES_BEGIN);

    }

}

void sentenciaSi(Ambito ambito) :
{
    Ambito ambitoSi = new Ambito(ambito);
} {

    try {
        <INICIO_CONDICIONAL_SI> expresion(ambito) <ENTONCES> ( sentencias(ambitoSi) )*
        (
            <CONDICIONAL_SINO>
            {
                ambitoSi = new Ambito(ambito);
            }
            ( sentencias(ambitoSi) )*
        )?
        <FIN_CONDICIONAL_SI>
    } catch (ParseException ex) {

        processError(ex, "sentencia condicional Si");

        skipTo(FIN_CONDICIONAL_SI);

    }

}

void sentenciaConforme(Ambito ambito) :
{
    boolean error = false;
    int tipoDatoCaso;
    Expresion exp = null;
    Ambito ambitoConforme;
    HashSet<String> casos = new HashSet<String>();
} {

    try {
        <INICIO_CONDICIONAL_CONFORME>
        <VARIABLE>
        {
            if (!ambito.tablaSimbolos.containsKey(token.image)) {

                tablaErrores.add("Error semántico, Línea " + token.beginLine + ", columna " + token.beginColumn
                               + ".\n\tEl símbolo \"" + token.image + "\" no está declarado en este ámbito."
                               + "\n\tDeclare una variable para asignarle un valor.");

                error = true;

            }

            if (!error) {
                exp = ambito.tablaSimbolos.get(token.image);

                if (exp.tipoExpresion != EXP_VARIABLE) {

                    tablaErrores.add("Error semántico, Línea " + token.beginLine + ", columna " + token.beginColumn
                                   + ".\n\tLa sentencia \"Segun\" solo funciona con variables.");

                    error = true;

                }

            }

        }
        <HACER>
        (
            <CASO>
            tipoDatoCaso = constantes()
            {

                if (!error && exp.tipoDato != tipoDatoCaso){

                    tablaErrores.add("Error semántico, Línea " + token.beginLine + ", columna " + token.beginColumn
                                   + ".\n\tTipo de dato del caso erróneo."
                                   + "\n\tEl caso debe tener un valor constante \"" + Expresion.getTipoDatoNombre(exp.tipoDato)  +"\".");

                    error = true;
                }

                if(!error && !casos.add(token.image)){

                    tablaErrores.add("Error semántico, Línea " + token.beginLine + ", columna " + token.beginColumn
                                   + ".\n\tEl caso \"" + token.image + "\" ya existe."
                                   + "\n\tElimine caso repetido.");
                }

                ambitoConforme = new Ambito(ambito);
            }
            <OPERADOR_DOS_PUNTOS>
            ( sentencias(ambitoConforme) )*
        )+
        ( <CASO_PREDETERMINADO> <OPERADOR_DOS_PUNTOS> ( sentencias(ambitoConforme) )* )?
        <FIN_CONFORME>
    } catch (ParseException ex) {

        processError(ex, "sentencia condicional Conforme");

        skipTo(FIN_CONFORME);

    }

}

void sentenciaPara(Ambito ambito) :
{
    Ambito ambitoPara = new Ambito(ambito);
} {

    try {
        <INICIO_CICLO_PARA> ( <VARIABLE> asignacion(ambito, new Tupla<Integer, Token>(-2, token) ) | declaracion(ambitoPara) )
        <CONDICION_CICLO_PARA> expresion(ambitoPara) <INCREMENTO_CICLO_PARA> ( <NUMERO_ENTERO> | <NUMERO_DECIMAL> )
        ( sentencias(ambitoPara) )*
        <FIN_CICLO_PARA>
    } catch (ParseException ex) {

        processError(ex, "sentencia de bucle Para");

        skipTo(FIN_CICLO_PARA);

    }


}

void sentenciaRepetir(Ambito ambito) :
{
    Ambito ambitoRepetir = new Ambito(ambito);
} {

    try {
        <INICIO_CICLO_REPETIR> ( sentencias(ambitoRepetir) )*
        <CONDICION_CICLO_REPETIR> expresion(ambito) <DELIMITADOR>
    } catch (ParseException ex) {

        processError(ex, "sentencia de bucle Repetir");

        skipTo(DELIMITADOR, SENTENCES_BEGIN);

    }

}

void sentenciaMientras(Ambito ambito) :
{
    Ambito ambitoMientras = new Ambito(ambito);
} {

    try {
        <INICIO_CICLO_MIENTRAS> expresion(ambito) <HACER>
        ( sentencias(ambitoMientras) )*
        <FIN_CICLO_MIENTRAS>
    } catch (ParseException ex) {

        processError(ex, "sentencia de bucle Mientras");

        skipTo(FIN_CICLO_MIENTRAS);

    }


}