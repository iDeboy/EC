
options {
    STATIC = false;
}

PARSER_BEGIN(EC)

    import java.io.*;
    import java.util.*;

    public class EC {


        public static void main(String[] args) {


        }

    }
    
PARSER_END(EC)

// Inicio y fin del programa
TOKEN : {

    <INICIO: "Inicio">
    |
    <FIN: "Fin">

}

// Tipos de dato
TOKEN : {

    <ENTERO: ("Entero" | "entero")>
    |
    <FLOTANTE : ("Flotante" | "flotante")>
    |
    <CADENA: ("Cadena" | "cadena")>
    |
    <CARACTER: ("Caracter" | "caracter")>
    |
    <BOOLEANO: ("Booleano" | "booleano")>
}

// Constantes/Literales
TOKEN : {
    <#LETRA: ["a" - "z", "ñ"] | ["A" - "Z", "Ñ"]>
    |
    <#NUMERO: ["0" - "9"]>
    |
    <CADENA_TEXTO: "\"" ( ~["\""] )* "\"">
    |
    <CARACTER_TEXTO: "'"( ~["'"] | "" )"'">
    |
    <NUMERO_ENTERO: ("-" | "" | "+")(<NUMERO>)+>
    |
    <NUMERO_DECIMAL: ("-" | "" | "+")(<NUMERO>)+"."(<NUMERO>)+>
    |
    <BOOLEANO_FALSO: "Falso">
    |
    <BOOLEANO_VERDADERO: "Verdadero">
    |
    <DELIMITADOR: ";">

}

// Escritura, Lectura y Definición de variables
TOKEN : {
    <INTERPRETAR: "Interpretar">
    |
    <ESCRIBIR: "Escribir">
    |
    <ESTABLECER: "Establecer">
}

// Operadores
TOKEN : {
    <ASIGNACION: "=">
    |
    <SUMA: "+">
    |
    <RESTA: "-">
    |
    <MULTIPLICACION: "*">
    |
    <DIVISION: "/">
    |
    <MODULO: "%">
    |
    <LOGICO_AND: "&&">
    |
    <LOGICO_OR: "||">
    |
    <LOGICO_NOT: "!">
    |
    <OPERADOR_IGUAL: "==">
    |
    <OPERADOR_DIFERENTE: "!=">
    |
    <OPERADOR_MAYOR: ">">
    |
    <OPERADOR_MENOR: "<">
    |
    <OPERADOR_MAYOR_IGUAL: ">=">
    |
    <OPERADOR_MENOR_IGUAL: "<=">
    |
    <OPERADOR_DOS_PUNTOS: ":">
    |
    <PAREN_ABIERTO: "(">
    |
    <PAREN_CERRADO: ")">
}

// Ciclos
TOKEN : {
    <INICIO_CICLO_PARA: "Para">
    |
    <CONDICION_CICLO_PARA: "Hasta que">
    |
    <INCREMENTO_CICLO_PARA: "Con incremento">
    |
    <FIN_CICLO_PARA: "FinPara">
    |
    <INICIO_CICLO_MIENTRAS: "Mientras">
    |
    <FIN_CICLO_MIENTRAS: "FinMientras">
    |
    <INICIO_CICLO_REPETIR: "Repetir">
    |
    <CONDICION_CICLO_REPETIR: "Finaliza cuando">
}

// Condicionales
TOKEN : {
    <INICIO_CONDICIONAL_SI:"Si">
    |
    <ENTONCES:"Entonces">
    |
    <CONDICIONAL_SINO:"Sino">
    |
    <FIN_CONDICIONAL_SI:"FinSi">
    |
    <INICIO_CONDICIONAL_CONFORME:"Conforme">
    |
    <CASO:"Caso">
    |
    <CASO_PREDETERMINADO:"En otro caso">
    |
    <FIN_CONFORME:"FinConforme">
    |
    <HACER : "Hacer">
}

//Variables
TOKEN : {
    <VARIABLE:(<LETRA> | "_")(<NUMERO> | <LETRA> | "_")*>

}

SKIP : {
    " "
    | "\t"
    | "\r\n"
    | "\n"
    | <COMENTARIO: "#"( ~["\n", "\r"] )*>

    // Tokens invalidos
    | <NUMERO_INVALIDO: ("-" | "" | "+")(<NUMERO>)*("."( <NUMERO> | <LETRA> )* | <LETRA>)+>
    | <INVALIDO: ~[]>{


    }

}

// Gramaticas

void programa(): { }{

    try {
        <INICIO> ( sentencias() )+ <FIN><EOF>
    } catch (ParseException ex){
        processError(ex, "programa principal");

        skipTo(FIN);
    }
}

void sentencias():{}{

    sentenciaAsignacion() |
    sentenciaDeclaracionVariables() |
    leerDato() |
    imprimirDato() |
    sentenciaSi() |
    sentenciaConforme() |
    sentenciaPara() |
    sentenciaRepetir() |
    sentenciaMientras()

}

void sentenciaAsignacion():{}{

    try {
        <VARIABLE> asignacion() <DELIMITADOR>
    } catch (ParseException ex) {

        processError(ex, "sentencia de asignacion");

        skipTo(DELIMITADOR, SENTENCES_BEGIN);

    }


}

void sentenciaDeclaracionVariables():{}{

    try {
        declaracionVariables() <DELIMITADOR>
    } catch (ParseException ex) {

        processError(ex, "sentencia de declaración de variable");

        skipTo(DELIMITADOR, SENTENCES_BEGIN);

    }

}

void tiposDato():{ }{
    <ENTERO> | <FLOTANTE> | <CADENA> | <CARACTER> | <BOOLEANO>
}

void constantes():{ }{
    <NUMERO_ENTERO> | <NUMERO_DECIMAL> | <CADENA_TEXTO> | <CARACTER_TEXTO> | <BOOLEANO_FALSO> | <BOOLEANO_VERDADERO>
}

void asignacion():{}{
    <ASIGNACION>  condicion()
}

void operacion():{ }{
    ( <LOGICO_NOT> )* ( <VARIABLE> | constantes() | operacionParentesis() )
    (operadores() ( <LOGICO_NOT> )* (<VARIABLE> | constantes() | operacionParentesis() ))*
}

void operacionParentesis():{}{
    <PAREN_ABIERTO> operacion() <PAREN_CERRADO>
}

void operadores():{}{
    operadoresAritmeticos() | operadoresLogicos() | operadoresRelacionales()
}

void operadoresAritmeticos():{}{
    <SUMA> | <RESTA> | <MULTIPLICACION> | <DIVISION> | <MODULO>
}

void operadoresRelacionales():{}{
    <OPERADOR_IGUAL> | <OPERADOR_DIFERENTE> | <OPERADOR_MAYOR> | <OPERADOR_MAYOR_IGUAL> | <OPERADOR_MENOR> | <OPERADOR_MENOR_IGUAL>
}

void operadoresLogicos():{}{
    <LOGICO_AND> | <LOGICO_OR>
}

void declaracionVariables():{}{
    <ESTABLECER> tiposDato() <VARIABLE> ( asignacion() )?
}

void leerDato():{}{

    try {
        <INTERPRETAR> <VARIABLE> <DELIMITADOR>
    } catch (ParseException ex) {

        processError(ex, "sentencia de lectura de dato");

        skipTo(DELIMITADOR, SENTENCES_BEGIN);

    }
}

void imprimirDato():{}{

    try {
        <ESCRIBIR> ( constantes() | <VARIABLE> ) <DELIMITADOR>
    } catch (ParseException ex) {

        processError(ex, "sentencia de escritura de dato");

        skipTo(DELIMITADOR, SENTENCES_BEGIN);

    }

}

void sentenciaSi():{}{

    try {
        <INICIO_CONDICIONAL_SI> condicion() <ENTONCES> ( sentencias() )+
        ( <CONDICIONAL_SINO> ( sentencias() )+ )?
        <FIN_CONDICIONAL_SI>
    } catch (ParseException ex) {

        processError(ex, "sentencia condicional Si");

        skipTo(FIN_CONDICIONAL_SI);

    }

}

// var1 + 5 < var2 - 2 || 3 + 6 != val3 % 5  <- Lograr esto (Hecho)
void condicion():{} {
    operacion()
    ( operadoresRelacionales() operacion() )*
}

void sentenciaConforme():{}{

    try {
        <INICIO_CONDICIONAL_CONFORME> <VARIABLE> <HACER>
        ( <CASO> constantes() <OPERADOR_DOS_PUNTOS> ( sentencias() )+ )+
        ( <CASO_PREDETERMINADO> <OPERADOR_DOS_PUNTOS> ( sentencias() )+ )?
        <FIN_CONFORME>
    } catch (ParseException ex) {

        processError(ex, "sentencia condicional Conforme");

        skipTo(FIN_CONFORME);

    }

}

void sentenciaPara():{}{

    try {
        <INICIO_CICLO_PARA> (<VARIABLE> <ASIGNACION> ( constantes() | <VARIABLE> ) | declaracionVariables() )
        <CONDICION_CICLO_PARA> condicion() <INCREMENTO_CICLO_PARA> ( <NUMERO_ENTERO> | <NUMERO_DECIMAL> )
        ( sentencias() )+
        <FIN_CICLO_PARA>
    } catch (ParseException ex) {

        processError(ex, "sentencia de bucle Para");

        skipTo(FIN_CICLO_PARA);

    }


}

void sentenciaRepetir():{}{

    try {
        <INICIO_CICLO_REPETIR> ( sentencias() )+
        <CONDICION_CICLO_REPETIR> condicion() <DELIMITADOR>
    } catch (ParseException ex) {

        processError(ex, "sentencia de bucle Repetir");

        skipTo(DELIMITADOR, SENTENCES_BEGIN);

    }

}

void sentenciaMientras():{}{

    try {
        <INICIO_CICLO_MIENTRAS> condicion() <HACER>
        ( sentencias() )+
        <FIN_CICLO_MIENTRAS>
    } catch (ParseException ex) {

        processError(ex, "sentencia de bucle Mientras");

        skipTo(FIN_CICLO_MIENTRAS);

    }


}

